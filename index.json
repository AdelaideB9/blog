[{"content":"Challenge description A robber broke into our vault in the middle of night. There\u0026rsquo;s an indication that the robber tried to steal some items which are considered as confidential assets. Could you figure it out?\nFlag format: IJCTF{[a-f0-9]{32}}\nAuthor: Avilia#1337\nHint #1: \u0026ldquo;When the incident happened, the attacker got into our IP over ICMP tunnel network to access an HTTP/2 web-server with SSL enabled.\u0026rdquo;\nHint #2: \u0026ldquo;Even so, our captured logs aren\u0026rsquo;t precise enough. Each packet has an unusual timestamp and it\u0026rsquo;s kinda messy\u0026hellip;\u0026rdquo;\nlog.tar.xz\nInvestigating the packet capture We are provided with a log.tar.xz archive from the challenge description, which we can decompress using xz and tar as so:\n$ xz -d log.tar.xz\n$ tar -xvf log.tar\nThis should produce a log.pcap file.\nRunning strings against the .pcap file, we pipe the output to sort and uniq to only display unique entries, then grep ...... to display only lines with length greater or equal to 6:\n$ strings log.pcap | sort | uniq | grep ......\n... CLIENT_RANDOM Compressed: 202 Extracting archive: flag.zip p7zip Version 16.02 (locale=C.UTF-8,Utf16=on,HugeFiles=on,32 bits,1 CPU LE) \u0026amp;p/home/pi/projects/ctf python3 download.py flag.zip python3 download.py pass.txt uid=1000(pi) gid=1000(pi) groups=1000(pi),4(adm),20(dialout),24(cdrom),27(sudo),29(audio),44(video),46(plugdev),60(games),100(users),105(input),109(netdev),114(docker),116(lpadmin),997(gpio),998(i2c),999(spi) whoami xargs -n1 -a sslkeylogfile We see mentions of files flag.zip, pass.txt, download.py, and sslkeylogfile, as well as commands such as id, python3 and xargs being run.\nOpening the packet capture file log.pcap in Wireshark, we see a conversation between 192.168.1.30 and 192.168.1.205 through ICMP (ping), along with some fragmented IPv4 packets.\n From the first hint, we know that the attacker used an IP over ICMP tunnel network to access an HTTP/2 web server with SSL. From the second hint, we also know that the capture logs were imprecise and the packet timestamps were unusual.  Looking at Wireshark, we notice some of the packets have negative time values. This should not be possible, packets cannot travel back in time before the capture started. Also, the frame numbers are all over the place and are not ordered correctly.\nWe can fix the packet ordering issue using the reordercap tool, which should come installed with Wireshark:\n$ reordercap log.pcap log_ordered.pcap\nIf the reordering was successful, there should be 167 fragmented IPv4 packets with size of 1514 bytes in the newly created log_ordered.pcap file. With the ordering fixed, we can then start analysing the individual packets.\nSplicing the packet headers Looking at one of the fragmented IPv4 packets, we see that there is a data segment with 1480 bytes of data:\nAt first, the data may look like random bytes. But, if we look carefully, we can see there is a malformed Ethernet header, followed by an IP header, and then a TCP header:\nSearching for the bytes in the malformed Ethernet header 00 00 4a e3 f9 24 34 44 68 61 6e 73 07, we were able to determine the specific application used to establish the ICMP tunnel, called \u0026ldquo;Hans\u0026rdquo; (https://github.com/friedrich/hans). This header is inserted by the Hans application. We can also see the 0x07 byte at the end, which is defined as TYPE_DATA in the source code under src/worker.h:\nenum Type { TYPE_RESET_CONNECTION = 1, TYPE_CONNECTION_REQUEST = 2, TYPE_CHALLENGE = 3, TYPE_CHALLENGE_RESPONSE = 4, TYPE_CONNECTION_ACCEPT = 5, TYPE_CHALLENGE_ERROR = 6, TYPE_DATA = 7, TYPE_POLL = 8, TYPE_SERVER_FULL = 9 }; We know the TCP data inside of the ICMP data has to contain the TLS traffic which the attacker used to exfiltrate data, or the handshakes associated with them. If we can somehow restore the original TLS packets, then there is a possibility where we can extract the session keys and use them to decrypt the rest of the packets.\nThis can be achieved by transplanting the Ethernet header from the ICMP packet to the ICMP data segment, and removing the magic/type header inserted by Hans. In fact, we can simplify it to only one cut operation by removing the TCP header and the Hans header altogether.\nUsing the editcap tool and following the documentation here, we cut away 33 bytes (20 bytes from TCP header of ICMP + 13 bytes from Hans) starting from offset byte 15 (after 14 bytes from Ethernet header of ICMP) for each packet, then export the packets into a log_chopped.pcap file:\n$ editcap -C 15:33 log_ordered.pcap log_chopped.pcap\nOpening log_chopped.pcap file in Wireshark, we see the ICMP packets have now changed into either TCP or Socks packets, the source/destination address and ports have also changed. This is likely because the attacker used a Socks proxy when attacking our victim. To combat this and allow Wireshark to read the traffic properly as TLS, we can add an entry to the \u0026ldquo;Decode As\u0026rdquo; list under the \u0026ldquo;Analyze\u0026rdquo; tab, pointing port 1080 to TLS:\nThis basically tells Wireshark to treat all traffic on TCP port 1080 as TLS, and not as Socks.\nExtracting the TLS session keys Earlier, when we did strings on the log.pcap file, we noticed that the attacker ran xargs -n1 -a sslkeylogfile on the victim\u0026rsquo;s system, which would effectively print the contents of sslkeylogfile to the output stream. We should be able to follow this output as it is not protected by TLS, and recover the TLS session keys.\nFrom the Mozilla NSS key log documentations, we know the sslkeylogfile follows a format of \u0026lt;Label\u0026gt; \u0026lt;space\u0026gt; \u0026lt;ClientRandom\u0026gt; \u0026lt;space\u0026gt; \u0026lt;Secret\u0026gt;. ClientRandom is encoded as 64 hexadecimal characters, and Secret is encoded as 96 hexadecimal characters (for TLS 1.0-2). For example, a key may look like this:\nCLIENT_RANDOM cf6b8752f4b47c9c28b07ba7da366f98afcc335931f08df83c30ebe2c7bcce32 a832cf19fa6b414fce74fa796b39d898c0825991547eebd20abe951ad2c586490d2703e4f596de3b6b4be417a2caa250 In log_chopped.pcap, we use Wireshark\u0026rsquo;s search feature to look for the string CLIENT_RANDOM in the packet bytes. Select any packet from the search result and follow the TCP stream by right-clicking on it then clicking Follow -\u0026gt; TCP Stream. This should open a new window showing the entire stream as ASCII:\nFrom here, it is trivial to extract the contents of sslkeylogfile. We can simply copy all lines containing the session keys starting from CLIENT_RANDOM and paste them into a file named sslkeylogfile.txt.\nThough, we\u0026rsquo;re not done quite yet. Since the attacker used xargs -n1 to display each argument into separate lines, the format of our keys is going to be incorrect. We need to replace the line characters \\n between ClientRandom and Secret into space characters, and this can be done using paste as so:\n$ paste -d\u0026quot; \u0026quot; - - - \u0026lt; sslkeylogfile.txt \u0026gt; sslkeylogfile\nThe sslkeylogfile should now contain 166 keys, as seen here:\n$ wc sslkeylogfile \u0026amp;\u0026amp; md5sum sslkeylogfile\n166 498 29216 sslkeylogfile 9776acd3c0499be64e9653cb27f30720 sslkeylogfile With the session keys extracted, we can then decrypt the packets.\nInjecting secrets and decrypting TLS traffic There are two ways we can approach the decryption:\n Use Wireshark\u0026rsquo;s built-in support for master secret log files for TLS under Preferences -\u0026gt; Protocol -\u0026gt; TLS -\u0026gt; (Pre)-Master-Secret log filename, select the sslkeylogfile we just extracted, and the packets will be automatically decrypted by Wireshark in the GUI. Use editcap to inject the secret to the .pcap file, as so: $ editcap --inject-secrets tls,sslkeylogfile log_chopped.pcap log_decrypted.pcap  Either methods will allow us to read the contents of the packets, but the editcap approach will allow us to use command-line tools later to recover the files more easily. If you want to hand transcribe hexadecimals later on, then choose method 1. ;)\nRecovering flag.zip and pass.txt Looking at the HTTP/2 packets in log_decrypted.pcap with filter http2, we see there are GET requests to /files/flag.zip and /files/pass.txt:\nAlongside the HEADERS and Magic packets, we also see many DATA packets. Inspecting them further with Wireshark, we see that each of the DATA packet has a status of 206 Partial Content, they each carry either 1 or 2 bytes of data depending on if the Content-Type header is text/plain or application/zip, and nearly all of them have an unusual header Content-Range.\nIn essence, what\u0026rsquo;s happening here - is that the attacker is gradually sending either 1 or 2 bytes of data through HTTP/2. The bytes are ordered by the Content-Range header. For example, bytes 22-23/202 would mean the data in the packet belongs in byte locations 22 to 23, out of 202 bytes. This implies, in order for us to recover the two files, we need to piece together the individual bytes of data from all of the DATA packets according to the Content-Range header.\nIt is possible to recover the files by hand transcribing the hexadecimals from all 166 packets (if you\u0026rsquo;re up for the task). Fortunately, there is a tool that can help us with this. We can use tshark, which is a packet analysis tool much like Wireshark, but it is capable of quickly exporting the packets' range and data as columns in the command-line, allowing us to easily recover the bytes.\n$ tshark -r log_decrypted.pcap -Y \u0026quot;http2\u0026quot; -T fields -e http2.headers.range -e http2.data.data | xargs -n2 \u0026gt; bytes.txt\nHere, we first take log_decrypted.pcap as the input file (-r), using http2 as the display filter (-Y), and printing the fields (-T) of http2.headers.range and http2.data.data (-e). We also pipe the output to xargs -n2 to make each packet display neatly on one line instead of two, and finally output it to a bytes.txt file. The file should look something like this:\nbytes=53-53 31 bytes=34-34 32 bytes=27-27 39 bytes=52-52 36 bytes=55-55 66 ... We have the hexadecimal bytes of flag.zip and pass.txt, but the bytes are mixed together in one file and we want to separate them. To do this, we can pass it through a few more filters:\n$ cat bytes.txt | awk 'length($2)==2 {print $0}' | cut -d\u0026quot;=\u0026quot; -f2 | sort -n\nThis reads the contents of bytes.txt, and prints the line if the byte column has a length of 2. Then removes the \u0026ldquo;bytes=\u0026rdquo; string before the range, and sorts the values numerically. The result should be the hexadecimal bytes of pass.txt in order of the range, and will look something like this:\n0-0 30 1-1 65 2-2 64 3-3 62 4-4 63 ... We can verify that no bytes are missing from the output, and that all bytes are in the correct order.\nNow, we just have to remove the range column and we will get the password\u0026rsquo;s hex:\n$ cat bytes.txt | awk 'length($2)==2 {print $0}' | cut -d\u0026quot;=\u0026quot; -f2 | sort -n | cut -d\u0026quot; \u0026quot; -f2 \u0026gt; pass.hex\nTo convert it from hexadecimal to bytes, we can use xxd:\n$ xxd -r -p pass.hex \u0026gt; pass.txt\nNow repeat the process for flag.zip, but this time using length($2)==4 instead. We can also skip the intermediate hex file as so:\n$ cat bytes.txt | awk 'length($2)==4 {print $0}' | cut -d\u0026quot;=\u0026quot; -f2 | sort -n | cut -d\u0026quot; \u0026quot; -f2 | xxd -r -p \u0026gt; flag.zip\nGetting the flag Now all that\u0026rsquo;s left to do is decompress flag.zip using pass.txt and get the flag!\n$ unzip flag.zip\nArchive: flag.zip [flag.zip] flag.txt password: 0edbca2531daefac9c5c84c016792713fd23681ea8bc1b3d088b617f75940313 extracting: flag.txt $ cat flag.txt\nIJCTF{aa51f2cc8eaf466a277da70db3a3c576} Resources  friedrich/hans: IP over ICMP - https://github.com/friedrich/hans editcap - The Wireshark Network Analyzer 3.4.7 - https://www.wireshark.org/docs/man-pages/editcap.html NSS Key Log Format - Mozilla MDN - https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format Wireshark Tutorial: Decrypting HTTPS Traffic - https://unit42.paloaltonetworks.com/wireshark-tutorial-decrypting-https-traffic/ Decrypting TLS Streams With Wireshark: Part 1 - https://blog.didierstevens.com/2020/12/14/decrypting-tls-streams-with-wireshark-part-1/ tshark - The Wireshark Network Analyzer 3.4.7 - https://www.wireshark.org/docs/man-pages/tshark.html  ","permalink":"https://blog.adelaideb9.com/posts/2021/ijctf/vault/","summary":"Challenge description A robber broke into our vault in the middle of night. There\u0026rsquo;s an indication that the robber tried to steal some items which are considered as confidential assets. Could you figure it out?\nFlag format: IJCTF{[a-f0-9]{32}}\nAuthor: Avilia#1337\nHint #1: \u0026ldquo;When the incident happened, the attacker got into our IP over ICMP tunnel network to access an HTTP/2 web-server with SSL enabled.\u0026rdquo;\nHint #2: \u0026ldquo;Even so, our captured logs aren\u0026rsquo;t precise enough.","title":"Vault - IJCTF 2021"},{"content":"For this challenge we are given a source file and a netcat server which presumably runs the source. Looking through the source code, we see that a integer is taken in as input and using this input, the flag is encrypted. The source is as follows:\n#!/usr/bin/python from functools import reduce with open(\u0026#34;flag\u0026#34;, \u0026#34;r\u0026#34;) as f: key = [ord(x) for x in f.read().strip()] def substitute(value): return (reduce(lambda x, y: x*value+y, key)) % 691 print(\u0026#34;Enter a number and it will be returned with our super secret synthetic substitution technique\u0026#34;) while True: try: value = input(\u0026#34;\u0026gt; \u0026#34;) if value == \u0026#39;quit\u0026#39;: quit() value = int(value) enc = substitute(value) print(\u0026#34;\u0026gt;\u0026gt; \u0026#34;, end=\u0026#34;\u0026#34;) print(enc) except ValueError: print(\u0026#34;Invalid input. \u0026#34;) The main function of interest to us is the substitute function.\ndef substitute(value): return (reduce(lambda x, y: x*value+y, key)) % 691 After researching what the reduce function does, we see that we are essentially recursively calling\n$$f(x,y) = kx+y$$\nwhere $k$ is the user input, $x$ is the previous result and $y$ is the next character in the flag. As $f$ is a linear function, we can produce the following linear equation.\n$$g(k) \\equiv x_0 k^{n-1}+x_1 k^{n-2}+\u0026hellip;+x_{n-2} k+x_{n-1} \\pmod{691}$$\nwhere $x_n$ is the $n$th character of the flag. To test our understanding, let us evaluate $g(0)$. As per $g(k)$, we should have $g(0)=x_{n-1}$. In other words, we should get the last letter of the flag, hence we should get the ASCII value of }. Connecting to the server and trying it, we indeed get $125$.\nKnowing this, we can make a $n \\times n$ linear system where the $n$th equation is the equation $g(n)$.\n$$\\begin{aligned}g(0) \u0026amp;\\equiv x_0 \\times 0^{n-1}+ x_1 \\times 0^{n-2}+ \u0026hellip; +x_{n-2} \\times 0+x{n-1} \\pmod{691} \\\\ g(1) \u0026amp;\\equiv x_0 \\times 1^{n-1}+ x_1 \\times 1^{n-2}+ \u0026hellip; +x_{n-2} \\times 1+x_{n-1} \\pmod{691} \\\\ g(2) \u0026amp;\\equiv x_0 \\times 2^{n-1}+ x_1 \\times 2^{n-2}+ \u0026hellip; +x_{n-2} \\times 2+x_{n-1} \\pmod{691} \\end{aligned}$$\nThis can be expressed as:\n$$A\\textbf{X}=\\textbf{B} \\pmod{691}$$\nwhere A is the coefficient matrix:\n$$\\begin{bmatrix}0^{n-1} \u0026amp; 0^{n-2} \u0026amp; \\cdots \u0026amp; 0^{1} \u0026amp; 1 \\\\ 1^{n-1} \u0026amp; 1^{n-2} \u0026amp; \\cdots \u0026amp; 1^{1} \u0026amp; 1 \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots \\\\ (n-2)^{n-1} \u0026amp; (n-2)^{n-2} \u0026amp; \\cdots \u0026amp; (n-2)^{1} \u0026amp; 1 \\\\ (n-1)^{n-1} \u0026amp; (n-1)^{n-2} \u0026amp; \\cdots \u0026amp; (n-1)^{1} \u0026amp; 1\\end{bmatrix}$$\nand B is the outputs for each given input:\n$$\\begin{bmatrix}g(0) \\\\ g(1) \\\\ \\vdots \\\\ g(n-2) \\\\ g(n-1) \\end{bmatrix}$$\nand $X$ is the matrix of characters (essentially the flag).\nWhile we are not sure as to how long the flag will be, it is reasonable to say it will be less that 100 characters (based off previously retrieved flags). Using this equation and the fact that the characters must be integers, we can solve the system over $\\mathbb{Z}\\pmod{691}$. This can be done with the following sage maths script that uses pwntools to connect to the server and collect the results.\nfrom pwn import * import re # Connecting with pwntools nc = remote(\u0026#39;crypto.2021.chall.actf.co\u0026#39;, 21601) nc.recvline() nums = [] for i in range(100): # Sending the numbers from 0-99 to the server and listening to the response nc.sendline(str(i)) res = str(nc.recvline()) # Stripping the number from the response and appending it to numbers nums.append(int(re.findall(\u0026#34;[0-9]+\u0026#34;, res)[0])) # Using sagemaths to solve the linear system M = matrix(ZZ, 100, 100, lambda x, y: pow(x, 99-y)) b = vector(GF(691), 100, nums) solution = M.solve_right(b) # Converting the solution into a string flag = \u0026#39;\u0026#39;.join(chr(c) for c in solution) print(flag) Sure enough, after a minute or so of running, we get the flag!\nactf{polynomials_20a829322766642530cf69}\n","permalink":"https://blog.adelaideb9.com/posts/2021/angstromctf/substitution/","summary":"For this challenge we are given a source file and a netcat server which presumably runs the source. Looking through the source code, we see that a integer is taken in as input and using this input, the flag is encrypted. The source is as follows:\n#!/usr/bin/python from functools import reduce with open(\u0026#34;flag\u0026#34;, \u0026#34;r\u0026#34;) as f: key = [ord(x) for x in f.read().strip()] def substitute(value): return (reduce(lambda x, y: x*value+y, key)) % 691 print(\u0026#34;Enter a number and it will be returned with our super secret synthetic substitution technique\u0026#34;) while True: try: value = input(\u0026#34;\u0026gt; \u0026#34;) if value == \u0026#39;quit\u0026#39;: quit() value = int(value) enc = substitute(value) print(\u0026#34;\u0026gt;\u0026gt; \u0026#34;, end=\u0026#34;\u0026#34;) print(enc) except ValueError: print(\u0026#34;Invalid input.","title":"Substitution - ångstromCTF 2021"},{"content":"notes I may not be familiar with .mem files but memory forensics, and more specifically volatility seems like its going to be our friend here.\nStarting with volatility -f image.mem imageinfo we get Win7SP1x64 as our top suggested profile, providing confirmation that we\u0026rsquo;ve got a valid dump.\nUsing one of volatility\u0026rsquo;s coolest features we can use mkdir shots \u0026amp;\u0026amp; volatility -f image.mem --profile=Win7SP1x64 screenshot --dump-dir=shots to get the following wire-frame screenshot from memory. Now we know that the flag was probably open in Notepad, given the hint \u0026ldquo;There wasn\u0026rsquo;t any suspicious network activity or anything\u0026hellip; it\u0026rsquo;s almost as if they just had their passwords up right on the screen.\u0026rdquo;\nTo grab the contents from Notepad we\u0026rsquo;ll want to first find it\u0026rsquo;s PID and then get a memory dump of said process to analyse.\nvolatility -f image.mem --profile=Win7SP1x64 pslist\nOffset(V) Name PID PPID Thds Hnds Sess Wow64 Start \\ ------------------ -------------------- ------ ------ ------ -------- ------ ------ ------------------------------ ... 0xfffffa8000dd0060 notepad.exe 2696 2288 4 309 1 0 2021-03-20 17:59:34 UTC+0000\\ ... volatility -f image.mem --profile=Win7SP1x64 memdump --dump-dir=./ -p 2696\nUnfortunately volatility doesn\u0026rsquo;t seem have a handy plugin to give us whatever text was written into Notepad, so we\u0026rsquo;ll just have to search the resultant dump for any strings that might be part of the flag.\ncat 2696.dmp | strings | grep UMASS\nNo luck, a few more greps later and its pretty clear that either the flag\u0026rsquo;s not there or its encoded in format that would make it difficult to find by simply searching through strings.\nFrom here a bit of intuition and luck might lead you to the idea that the user may have copied the flag from Notepad onto their clipboard \u0026hellip;\nvolatility -f image.mem --profile=Win7SP1x64 clipboard\nSession WindowStation Format Handle Object Data ---------- ------------- ------------------ ------------------ ------------------ -------------------------------------------------- 1 WinSta0 CF_UNICODETEXT 0x5a00b5 0xfffff900c26aeb60 VU1BU1N7JDNDVVIzXyQ3MFJhZzN9Cg== 1 WinSta0 CF_TEXT 0x64006e00000010 ------------------ 1 WinSta0 0x13c01b7L 0x0 ------------------ 1 WinSta0 CF_TEXT 0x1 ------------------ 1 ------------- ------------------ 0x13c01b7 0xfffff900c06fa270 \u0026hellip; and you\u0026rsquo;d be right, we got some data! Judging by that padding it\u0026rsquo;s base64 encoded. Decoding it gives us the flag UMASS{$3CUR3_$70Rag3} 🥳\n","permalink":"https://blog.adelaideb9.com/posts/2021/umass/notes/","summary":"notes I may not be familiar with .mem files but memory forensics, and more specifically volatility seems like its going to be our friend here.\nStarting with volatility -f image.mem imageinfo we get Win7SP1x64 as our top suggested profile, providing confirmation that we\u0026rsquo;ve got a valid dump.\nUsing one of volatility\u0026rsquo;s coolest features we can use mkdir shots \u0026amp;\u0026amp; volatility -f image.mem --profile=Win7SP1x64 screenshot --dump-dir=shots to get the following wire-frame screenshot from memory.","title":"notes - UMassCTF '21"},{"content":"Investigating the mystery PDF File We\u0026rsquo;re given a modified PDF file of the infamous research paper, \u0026ldquo;Chicken Chicken Chicken: Chicken Chicken\u0026rdquo;, by Doug Zongker at the University of Washington.\nchicken.pdf\nSince we know this is a published research paper, we can download a copy of the original PDF file and compare the two for any difference:\nWe see that at around line 202, there is an extra OpenAction object inserted into the document, with a data stream beginning with 7z:\n$ hexdump -C chicken.pdf | grep 7z -A 11\n00001980 0d 0a 37 7a bc af 27 1c 00 04 2b 65 00 6c 30 00 |..7z..'...+e.l0.| 00001990 00 00 00 00 00 00 6a 00 00 00 00 00 00 00 4c 6a |......j.......Lj| 000019a0 b9 1e 0c fd be 4f 3b 93 39 58 52 bd 23 ea 0b 2d |.....O;.9XR.#..-| 000019b0 8d d1 a2 79 55 0b d8 05 68 43 0d ae 06 d5 2d f8 |...yU...hC....-.| 000019c0 25 ff b4 16 8d 21 3b 88 16 35 44 69 6d 5c 0e 59 |%....!;..5Dim\\.Y| 000019d0 a7 b3 01 04 06 00 01 09 30 00 07 0b 01 00 02 24 |........0......$| 000019e0 06 f1 07 01 0a 53 07 56 f2 43 9d 21 42 28 ae 21 |.....S.V.C.!B(.!| 000019f0 21 01 00 01 00 0c 29 25 00 08 0a 01 4e 5d 1c 8e |!.....)%....N]..| 00001a00 00 00 05 01 19 09 00 00 00 00 00 00 00 00 00 11 |................| 00001a10 0f 00 73 00 65 00 63 00 72 00 65 00 74 00 00 00 |..s.e.c.r.e.t...| 00001a20 19 04 00 00 00 00 14 0a 01 00 80 33 4a 2c b7 1d |...........3J,..| 00001a30 d7 01 15 06 01 00 20 80 a4 81 00 00 0a 65 6e 64 |...... ......end| The data stream starts with the 7z magic bytes, confirming that it is indeed a 7z file:\nList of file signatures - Wikipedia\nLet\u0026rsquo;s extract the stream with a bit of Bash-fu to a chicken.hex file:\n$ hexdump -C chicken.pdf | grep 7z -A 11 | cut -d ' ' -f3- | rev | cut -d ' ' -f3- | rev \u0026gt; chicken.hex\n0d 0a 37 7a bc af 27 1c 00 04 2b 65 00 6c 30 00 00 00 00 00 00 00 6a 00 00 00 00 00 00 00 4c 6a b9 1e 0c fd be 4f 3b 93 39 58 52 bd 23 ea 0b 2d 8d d1 a2 79 55 0b d8 05 68 43 0d ae 06 d5 2d f8 25 ff b4 16 8d 21 3b 88 16 35 44 69 6d 5c 0e 59 a7 b3 01 04 06 00 01 09 30 00 07 0b 01 00 02 24 06 f1 07 01 0a 53 07 56 f2 43 9d 21 42 28 ae 21 21 01 00 01 00 0c 29 25 00 08 0a 01 4e 5d 1c 8e 00 00 05 01 19 09 00 00 00 00 00 00 00 00 00 11 0f 00 73 00 65 00 63 00 72 00 65 00 74 00 00 00 19 04 00 00 00 00 14 0a 01 00 80 33 4a 2c b7 1d d7 01 15 06 01 00 20 80 a4 81 00 00 0a 65 6e 64 From reading the technical specifications of the 7z file format, we know the file has to begin with 37 7A BC AF 27 1C and end with 00 00. Therefore, we can trim off the starting 0D 0A and the ending 0A 65 6E 64 bytes, as they are not a part of the file.\nConvert the hex dump to a 7z file:\n$ xxd -r -p chicken.hex chicken.7z\nExtracting and cracking 7z password hash with John the Ripper Upon trying to extract the 7z file, we\u0026rsquo;re greeted with a password prompt:\n$ 7z x chicken.7z\n7-Zip [64] 17.03 : Copyright (c) 1999-2020 Igor Pavlov : 2017-08-28 p7zip Version 17.03 (locale=en_AU.UTF-8,Utf16=on,HugeFiles=on,64 bits,8 CPUs x64) Scanning the drive for archives: 1 file, 186 bytes (1 KiB) Extracting archive: chicken.7z -- Path = chicken.7z Type = 7z Physical Size = 186 Headers Size = 138 Method = LZMA2:12 7zAES Solid = - Blocks = 1 Enter password (will not be echoed): _  We can obtain the password hash with 7z2john:\n$ 7z2john ./chicken.7z \u0026gt; chicken.hash\nchicken.7z:$7z$2$19$0$$8$56f2439d214228ae0000000000000000$2384223566$48$41$0cfdbe4f3b93395852bd23ea0b2d8dd1a279550bd80568430dae06d52df825ffb4168d213b88163544696d5c0e59a7b3$37$00  Now that we have the password hash, let\u0026rsquo;s crack it using John with the rockyou.txt wordlist:\n$ john chicken.hash --wordlist=rockyou.txt --format=7z-opencl\nDevice 2@arch-zippy: GeForce GTX 1070 Using default input encoding: UTF-8 Loaded 1 password hash (7z-opencl, 7-Zip [SHA256 AES OpenCL]) Cost 1 (iteration count) is 524288 for all loaded hashes Cost 2 (padding size) is 7 for all loaded hashes Cost 3 (compression type) is 2 for all loaded hashes Will run 8 OpenMP threads Press 'q' or Ctrl-C to abort, almost any other key for status 0g 0:00:00:15 0.36% (ETA: 00:59:49) 0g/s 3576p/s 3576c/s 3576C/s Dev#2:61°C iiloveyou..simone13 0g 0:00:11:47 16.93% (ETA: 00:59:03) 0g/s 3736p/s 3736c/s 3736C/s Dev#2:59°C yahoomylove..y2j341 0g 0:00:19:51 29.15% (ETA: 00:57:34) 0g/s 3643p/s 3643c/s 3643C/s Dev#2:60°C rebel9250..rdoleo pineapple95 (chicken.7z) 1g 0:00:21:25 DONE (2021-03-29 00:10) 0.000778g/s 3627p/s 3627c/s 3627C/s Dev#2:59°C pinkice88..pincy Use the \u0026quot;--show\u0026quot; option to display all of the cracked passwords reliably Session completed  After 21 gruelling minutes, we get the cracked password:\npineapple95\nExtract the 7z:\n$ 7z x chicken.7z\n7-Zip [64] 17.03 : Copyright (c) 1999-2020 Igor Pavlov : 2017-08-28 p7zip Version 17.03 (locale=en_AU.UTF-8,Utf16=on,HugeFiles=on,64 bits,8 CPUs x64) Scanning the drive for archives: 1 file, 186 bytes (1 KiB) Extracting archive: chicken.7z -- Path = chicken.7z Type = 7z Physical Size = 186 Headers Size = 138 Method = LZMA2:12 7zAES Solid = - Blocks = 1 Enter password (will not be echoed): pineapple95 Everything is Ok Size: 37 Compressed: 186  The 7z file contains a secret file, let\u0026rsquo;s read it:\n$ cat secret\nVU1BU1N7QF9sIUxfNW03SCFuXzN4N3JAfQo=  This string seems to be encoded in base64, as hinted by the = padding. Decoding it gives:\n$ echo \u0026quot;VU1BU1N7QF9sIUxfNW03SCFuXzN4N3JAfQo=\u0026quot; | base64 -d\nUMASS{@_l!L_5m7H!n_3x7r@}  Winner winner chicken dinner, we got the flag!\nResources  https://isotropic.org/papers/chicken.pdf http://myexperimentswithmalware.blogspot.com/2014/09/pdf-analysis-with-peepdf.html https://en.wikipedia.org/wiki/List_of_file_signatures https://www.7-zip.org/recover.html  ","permalink":"https://blog.adelaideb9.com/posts/2021/umass/chicken/","summary":"Investigating the mystery PDF File We\u0026rsquo;re given a modified PDF file of the infamous research paper, \u0026ldquo;Chicken Chicken Chicken: Chicken Chicken\u0026rdquo;, by Doug Zongker at the University of Washington.\nchicken.pdf\nSince we know this is a published research paper, we can download a copy of the original PDF file and compare the two for any difference:\nWe see that at around line 202, there is an extra OpenAction object inserted into the document, with a data stream beginning with 7z:","title":"Chicken - UMassCTF '21"},{"content":"The Heim Upon navigating to the given URL, we\u0026rsquo;re met with a login form which asks the user for a \u0026ldquo;name\u0026rdquo;, claiming that \u0026ldquo;only those who BEARER a token may enter\u0026rdquo;.\nAfter entering a name and hitting \u0026ldquo;Enter\u0026rdquo;, we are then redirected to the /auth/authorised page containing our access token:\nThis likely suggests that we\u0026rsquo;re dealing with some type of bearer token authentication. Bearer tokens allow requests to authenticate by using a cryptic string generated and encrypted by the server, such as a JSON Web Token, which looks something akin to this:\nThis token is then included in the HTTP header, in the format of:\nAuthorization: Bearer \u0026lt;JWT\u0026gt; Intercepting requests with Burp Suite Let\u0026rsquo;s intercept the outbound POST request made to /auth with Burp Suite\u0026rsquo;s proxy feature, and forward the request to the repeater with Ctrl-R to try and figure out what is happening behind the scenes:\nWe see that the browser first makes a POST request to /auth with the form data, and is then redirected to the URL:\n/auth?access_token=\u0026lt;JWT\u0026gt;\u0026amp;jwt_secret_key=arottenbranchwillbefoundineverytree\nLeaked at the end of the redirect URL is the jwt_secret_key, which is used for encrypting JSON Web Tokens:\narottenbranchwillbefoundineverytree\nWhile looking for more API endpoints on the website by trying related keywords, we stumbled upon /heim, which returned:\n{ \u0026#34;msg\u0026#34;: \u0026#34;Missing Authorization Header\u0026#34; } This means that the web server is expecting a Bearer token in the HTTP header, so let\u0026rsquo;s add that to our request in Burp Suite\u0026rsquo;s repeater:\nWe received a massive message encoded in base64, let\u0026rsquo;s decode it:\n$ echo \u0026quot;ewogICAgIm...AgIH0KfQ==\u0026quot; | base64 -d\n{ \u0026#34;api\u0026#34;: { \u0026#34;v1\u0026#34;: { \u0026#34;/auth\u0026#34;: { \u0026#34;get\u0026#34;: { \u0026#34;summary\u0026#34;: \u0026#34;Debugging method for authorization post\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;None\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;access_token\u0026#34;: { \u0026#34;required\u0026#34;: true, \u0026#34;description\u0026#34;: \u0026#34;Access token from recently authorized Viking\u0026#34;, \u0026#34;in\u0026#34;: \u0026#34;path\u0026#34;, }, \u0026#34;jwt_secret_key\u0026#34;: { \u0026#34;required\u0026#34;: false, \u0026#34;description\u0026#34;: \u0026#34;Debugging - should be removed in prod Heim\u0026#34;, \u0026#34;in\u0026#34;: \u0026#34;path\u0026#34; } } }, \u0026#34;post\u0026#34;: { \u0026#34;summary\u0026#34;: \u0026#34;Authorize yourself as a Viking\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;None\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;username\u0026#34;: { \u0026#34;required\u0026#34;: true, \u0026#34;description\u0026#34;: \u0026#34;Your Viking name\u0026#34;, \u0026#34;in\u0026#34;: \u0026#34;body\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;multipart/x-www-form-urlencoded\u0026#34; } } } }, \u0026#34;/heim\u0026#34;: { \u0026#34;get\u0026#34;: { \u0026#34;summary\u0026#34;: \u0026#34;List the endpoints available to named Vikings\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;BearerAuth\u0026#34; } }, \u0026#34;/flag\u0026#34;: { \u0026#34;get\u0026#34;: { \u0026#34;summary\u0026#34;: \u0026#34;Retrieve the flag\u0026#34;, \u0026#34;security\u0026#34;: \u0026#34;BearerAuth\u0026#34; } } } } } Nice! We have obtained a list of all available endpoints and now know the flag is located at /flag, and that the GET method for /auth was originally meant to be a debugging endpoint, explaining why jwt_secret_key was leaked in the redirect URL.\nMaking a GET request to /flag with our Bearer token returns:\n{ \u0026#34;msg\u0026#34;: \u0026#34;You are not worthy. Only the AllFather Odin may view the flag\u0026#34; } Seems like only Odin is worthy enough to view the flag! Also, trying to submit \u0026ldquo;odin\u0026rdquo; as the name in the login form returns:\n{ \u0026#34;error\u0026#34;: \u0026#34;You are not wise enough to be Odin\u0026#34; } Though, since we can obtain a sample access token and are in possession of the secret key, we can forge our own tokens to authenticate as the Odin user.\nForging Odin\u0026rsquo;s token Using CyberChef tool, we can easily read the payload of our own JWT string with the \u0026ldquo;JWT decode\u0026rdquo; function:\nWe see that the JWT payload contains the following data:\n{ \u0026#34;fresh\u0026#34;: false, \u0026#34;iat\u0026#34;: 1617017482, \u0026#34;jti\u0026#34;: \u0026#34;380b9f5c-fb31-479e-a189-59e2c8040453\u0026#34;, \u0026#34;nbf\u0026#34;: 1617017482, \u0026#34;type\u0026#34;: \u0026#34;access\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;samiko\u0026#34;, \u0026#34;exp\u0026#34;: 1617018382 } Of all variables, sub (subject) and exp (expiration time) are the ones that appear most interesting to us, since we want to forge a token for Odin (that never expires!), so let\u0026rsquo;s modify the payload to the following:\n{ \u0026#34;fresh\u0026#34;: false, \u0026#34;iat\u0026#34;: 1617017482, \u0026#34;jti\u0026#34;: \u0026#34;380b9f5c-fb31-479e-a189-59e2c8040453\u0026#34;, \u0026#34;nbf\u0026#34;: 1617017482, \u0026#34;type\u0026#34;: \u0026#34;access\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;odin\u0026#34;, \u0026#34;exp\u0026#34;: 9999999999 } Using the \u0026ldquo;JWT Sign\u0026rdquo; function with the leaked jwt_secret_key and HS256 as parameters, we get the token:\nUsing the forged token in the HTTP header as a Bearer token, we make a GET request to /flag:\nVoila! We got the flag:\nUMASS{liveheim_laughheim_loveheim} Resources  https://swagger.io/docs/specification/authentication/bearer-authentication/ https://research.securitum.com/jwt-json-web-token-security/ https://gchq.github.io/CyberChef/  ","permalink":"https://blog.adelaideb9.com/posts/2021/umass/heim/","summary":"The Heim Upon navigating to the given URL, we\u0026rsquo;re met with a login form which asks the user for a \u0026ldquo;name\u0026rdquo;, claiming that \u0026ldquo;only those who BEARER a token may enter\u0026rdquo;.\nAfter entering a name and hitting \u0026ldquo;Enter\u0026rdquo;, we are then redirected to the /auth/authorised page containing our access token:\nThis likely suggests that we\u0026rsquo;re dealing with some type of bearer token authentication. Bearer tokens allow requests to authenticate by using a cryptic string generated and encrypted by the server, such as a JSON Web Token, which looks something akin to this:","title":"Heim - UMassCTF '21"},{"content":"The challenge description starts \u0026lsquo;My buddies Whitfield and Martin were trying to share a secret key\u0026rsquo;, so googling something like \u0026lsquo;Whitfield Martin cipher\u0026rsquo; seems like a good place to begin. Immediately we get results for the Diffie–Hellman key exchange, which fortunately can be described in terms of A, B, p, g, and s (the value of the secret key we need).\nScripts to brute-force this secret key are easy to find on GitHub. We used this DHAttack.py script to get the flag utflag{53919}, although there are some much faster alternatives. Try this script to get the flag yourself:\n#!/usr/bin/python3 # Based on github.com/DrMMZ/Attack-Diffie-Hellman p = 69691 g = 1001 A = 17016 B = 47643 for x in range(1, p): # or (g**x) % p == B if (g**x) % p == A: a = x s = (B**a) % p # or (A**b) % p print(s) ","permalink":"https://blog.adelaideb9.com/posts/2021/utctf/small-p-problems/","summary":"The challenge description starts \u0026lsquo;My buddies Whitfield and Martin were trying to share a secret key\u0026rsquo;, so googling something like \u0026lsquo;Whitfield Martin cipher\u0026rsquo; seems like a good place to begin. Immediately we get results for the Diffie–Hellman key exchange, which fortunately can be described in terms of A, B, p, g, and s (the value of the secret key we need).\nScripts to brute-force this secret key are easy to find on GitHub.","title":"Small P Problems - UTCTF 2021"},{"content":"We\u0026rsquo;re given the encrypted flag wmysau{foeim_Tfusoli} along with some additional encrypted text to help us \u0026lsquo;Hkgxologflutleiaymt xgf Azutgkrftmtf ltmntf ERW wfr ELW wfmtk Rkweq\u0026rsquo;.\nSome familiarity with common ciphers, along with the hint \u0026lsquo;This is a substitution cipher\u0026rsquo;, give us a pretty good direction to pursue so we decided to use this online tool for brute-forcing the solution.\nHowever, trying brute-forcing the text rendered nothing more decipherable than the initial text. Instead we look to the challenge title, where we find that the word vernacular refers to local languages or dialects. Perhaps the cipher text is in a different language? The hint \u0026lsquo;The plaintext may not necessarily be in English\u0026rsquo; confirms this.\nSome experimentation with different languages and google translates produces the string in German \u0026lsquo;provisionsgeschmüte von mageordneten setzen cdu und csu unter druck\u0026rsquo;. In English, \u0026lsquo;disregarding commissions from the ordered people put cdu and csu under pressure.\u0026rsquo; Looks like we found a valid substitution! Trying (using all English characters) on the encrypted flag, with attention to capitalisation, gave us utflag{nicht_English}.\n","permalink":"https://blog.adelaideb9.com/posts/2021/utctf/various-vernacular/","summary":"We\u0026rsquo;re given the encrypted flag wmysau{foeim_Tfusoli} along with some additional encrypted text to help us \u0026lsquo;Hkgxologflutleiaymt xgf Azutgkrftmtf ltmntf ERW wfr ELW wfmtk Rkweq\u0026rsquo;.\nSome familiarity with common ciphers, along with the hint \u0026lsquo;This is a substitution cipher\u0026rsquo;, give us a pretty good direction to pursue so we decided to use this online tool for brute-forcing the solution.\nHowever, trying brute-forcing the text rendered nothing more decipherable than the initial text.","title":"Various Vernacular - UTCTF 2021"},{"content":"Browser Bias This challenge gives us very little information, just a url to a site that tells us Sorry, this site is only optimized for browsers that run on commodo 64. However, this also narrows our focus down to a singular goal - trying to convince the website that we are accessing it from a whatever a \u0026lsquo;commodo 64\u0026rsquo; is.\nThe first thing we need to know is how the browser can determine what type of client is making a request to it. It turns out, a site can only determine this through the User-Agent header. We can manipulate this information in a variety of ways - like with browser extensions or on some browsers using the Developer Tools - but for the sake of controlling exactly what headers are passed over we made this handy little python function.\n{% gist 889226036803bab244ae41b127dc0ab3 %}\nNext we have to figure out what our user-agent string should actually be. If we pass \u0026lsquo;commodo 64\u0026rsquo; as the user-agent parameter of our function nothing changes. Googling commodo 64, we get results for the 1982 computer, The Commodore 64, but making that the header doesn\u0026rsquo;t work either. The part of the challenge we\u0026rsquo;re forgeting is that the site requires browsers that run on commodo 64. We need to find the header of a browser that works on the Commodore 64 \u0026hellip;\n\u0026hellip; here\u0026rsquo;s one! Hyperlink/2.5e (Commodore 64)\nPut that into our function and we get Welcome fellow c64 user. flag{8b1t_w3b}\nRobot Talk We found the best way to comunicate with challenges.neverlanctf.com:1120 was through Telnet!\nHere\u0026rsquo;s the handy script we made \u0026hellip;\n{% gist 5edbe8981351b9213bad90cd38135a0d %}\n\u0026hellip; and here\u0026rsquo;s the outputted flag flag{Ant1_hum4n}\nBitsnBytes Given the \u0026lsquo;programming\u0026rsquo; category, the title, and the fact that we are only linked to an image with green and gray squres, we figured that each colour represented a bit (1 or 0 in binary) and we had to write a script that would translate it.\n{% gist 24c0d9afe556dba4f84e383b62d4469b %}\nHere, each green square is decoded as a zero, and each gray is a one. Since this is an svg, which is conveniently a file type where infomation is stored in plain text, we didn\u0026rsquo;t need to bring out any python image-processing libraries. Then we would convert the binary string to plain text.\nThe problem was, we weren\u0026rsquo;t getting the flag - we were getting something like this time hash:076a1b24abb4870fc5eb892de796b5b32642f95664c04ff0d9b2b96c58a0b. The trick to this challenge was that the server only spits out the image of the encoded flag at hourly intervals, during the minute after the clock has shifted to the new hour. Once we got the right image we also got Now you've got it! Here's your flag: flag{its_all_ab0ut_timing}.\n","permalink":"https://blog.adelaideb9.com/posts/2020/neverlan/","summary":"Browser Bias This challenge gives us very little information, just a url to a site that tells us Sorry, this site is only optimized for browsers that run on commodo 64. However, this also narrows our focus down to a singular goal - trying to convince the website that we are accessing it from a whatever a \u0026lsquo;commodo 64\u0026rsquo; is.\nThe first thing we need to know is how the browser can determine what type of client is making a request to it.","title":"NeverLAN CTF 2020 Write-up"}]