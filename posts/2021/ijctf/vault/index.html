<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Vault - IJCTF 2021 | AdelaideB9 Blog</title><meta name=keywords content><meta name=description content="A forensics category challenge on recovering TLS session keys from a packet capture, and decrypting TLS traffic tunnelled over ICMP (ping) through a SOCKS proxy, then recovering files from partial HTTP/2 requests."><meta name=author content="samiko"><link rel=canonical href=https://blog.adelaideb9.com/posts/2021/ijctf/vault/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.adelaideb9.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.adelaideb9.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.adelaideb9.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.adelaideb9.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.adelaideb9.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})'></script><meta property="og:title" content="Vault - IJCTF 2021"><meta property="og:description" content="A forensics category challenge on recovering TLS session keys from a packet capture, and decrypting TLS traffic tunnelled over ICMP (ping) through a SOCKS proxy, then recovering files from partial HTTP/2 requests."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.adelaideb9.com/posts/2021/ijctf/vault/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-26T05:38:55+00:00"><meta property="article:modified_time" content="2021-07-26T05:38:55+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Vault - IJCTF 2021"><meta name=twitter:description content="A forensics category challenge on recovering TLS session keys from a packet capture, and decrypting TLS traffic tunnelled over ICMP (ping) through a SOCKS proxy, then recovering files from partial HTTP/2 requests."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.adelaideb9.com/posts/"},{"@type":"ListItem","position":2,"name":"Vault - IJCTF 2021","item":"https://blog.adelaideb9.com/posts/2021/ijctf/vault/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Vault - IJCTF 2021","name":"Vault - IJCTF 2021","description":"A forensics category challenge on recovering TLS session keys from a packet capture, and decrypting TLS traffic tunnelled over ICMP (ping) through a SOCKS proxy, then recovering files from partial HTTP/2 requests.","keywords":[],"articleBody":"Challenge description A robber broke into our vault in the middle of night. There’s an indication that the robber tried to steal some items which are considered as confidential assets. Could you figure it out?\nFlag format: IJCTF{[a-f0-9]{32}}\nAuthor: Avilia#1337\nHint #1: “When the incident happened, the attacker got into our IP over ICMP tunnel network to access an HTTP/2 web-server with SSL enabled.”\nHint #2: “Even so, our captured logs aren’t precise enough. Each packet has an unusual timestamp and it’s kinda messy…”\nlog.tar.xz\nInvestigating the packet capture We are provided with a log.tar.xz archive from the challenge description, which we can decompress using xz and tar as so:\n$ xz -d log.tar.xz\n$ tar -xvf log.tar\nThis should produce a log.pcap file.\nRunning strings against the .pcap file, we pipe the output to sort and uniq to only display unique entries, then grep ...... to display only lines with length greater or equal to 6:\n$ strings log.pcap | sort | uniq | grep ......\n... CLIENT_RANDOM Compressed: 202 Extracting archive: flag.zip p7zip Version 16.02 (locale=C.UTF-8,Utf16=on,HugeFiles=on,32 bits,1 CPU LE) \u0026p/home/pi/projects/ctf python3 download.py flag.zip python3 download.py pass.txt uid=1000(pi) gid=1000(pi) groups=1000(pi),4(adm),20(dialout),24(cdrom),27(sudo),29(audio),44(video),46(plugdev),60(games),100(users),105(input),109(netdev),114(docker),116(lpadmin),997(gpio),998(i2c),999(spi) whoami xargs -n1 -a sslkeylogfile We see mentions of files flag.zip, pass.txt, download.py, and sslkeylogfile, as well as commands such as id, python3 and xargs being run.\nOpening the packet capture file log.pcap in Wireshark, we see a conversation between 192.168.1.30 and 192.168.1.205 through ICMP (ping), along with some fragmented IPv4 packets.\nFrom the first hint, we know that the attacker used an IP over ICMP tunnel network to access an HTTP/2 web server with SSL. From the second hint, we also know that the capture logs were imprecise and the packet timestamps were unusual. Looking at Wireshark, we notice some of the packets have negative time values. This should not be possible, packets cannot travel back in time before the capture started. Also, the frame numbers are all over the place and are not ordered correctly.\nWe can fix the packet ordering issue using the reordercap tool, which should come installed with Wireshark:\n$ reordercap log.pcap log_ordered.pcap\nIf the reordering was successful, there should be 167 fragmented IPv4 packets with size of 1514 bytes in the newly created log_ordered.pcap file. With the ordering fixed, we can then start analysing the individual packets.\nSplicing the packet headers Looking at one of the fragmented IPv4 packets, we see that there is a data segment with 1480 bytes of data:\nAt first, the data may look like random bytes. But, if we look carefully, we can see there is a malformed Ethernet header, followed by an IP header, and then a TCP header:\nSearching for the bytes in the malformed Ethernet header 00 00 4a e3 f9 24 34 44 68 61 6e 73 07, we were able to determine the specific application used to establish the ICMP tunnel, called “Hans” (https://github.com/friedrich/hans). This header is inserted by the Hans application. We can also see the 0x07 byte at the end, which is defined as TYPE_DATA in the source code under src/worker.h:\nenum Type { TYPE_RESET_CONNECTION = 1, TYPE_CONNECTION_REQUEST = 2, TYPE_CHALLENGE = 3, TYPE_CHALLENGE_RESPONSE = 4, TYPE_CONNECTION_ACCEPT = 5, TYPE_CHALLENGE_ERROR = 6, TYPE_DATA = 7, TYPE_POLL = 8, TYPE_SERVER_FULL = 9 }; We know the TCP data inside of the ICMP data has to contain the TLS traffic which the attacker used to exfiltrate data, or the handshakes associated with them. If we can somehow restore the original TLS packets, then there is a possibility where we can extract the session keys and use them to decrypt the rest of the packets.\nThis can be achieved by transplanting the Ethernet header from the ICMP packet to the ICMP data segment, and removing the magic/type header inserted by Hans. In fact, we can simplify it to only one cut operation by removing the TCP header and the Hans header altogether.\nUsing the editcap tool and following the documentation here, we cut away 33 bytes (20 bytes from TCP header of ICMP + 13 bytes from Hans) starting from offset byte 15 (after 14 bytes from Ethernet header of ICMP) for each packet, then export the packets into a log_chopped.pcap file:\n$ editcap -C 15:33 log_ordered.pcap log_chopped.pcap\nOpening log_chopped.pcap file in Wireshark, we see the ICMP packets have now changed into either TCP or Socks packets, the source/destination address and ports have also changed. This is likely because the attacker used a Socks proxy when attacking our victim. To combat this and allow Wireshark to read the traffic properly as TLS, we can add an entry to the “Decode As” list under the “Analyze” tab, pointing port 1080 to TLS:\nThis basically tells Wireshark to treat all traffic on TCP port 1080 as TLS, and not as Socks.\nExtracting the TLS session keys Earlier, when we did strings on the log.pcap file, we noticed that the attacker ran xargs -n1 -a sslkeylogfile on the victim’s system, which would effectively print the contents of sslkeylogfile to the output stream. We should be able to follow this output as it is not protected by TLS, and recover the TLS session keys.\nFrom the Mozilla NSS key log documentations, we know the sslkeylogfile follows a format of . ClientRandom is encoded as 64 hexadecimal characters, and Secret is encoded as 96 hexadecimal characters (for TLS 1.0-2). For example, a key may look like this:\nCLIENT_RANDOM cf6b8752f4b47c9c28b07ba7da366f98afcc335931f08df83c30ebe2c7bcce32 a832cf19fa6b414fce74fa796b39d898c0825991547eebd20abe951ad2c586490d2703e4f596de3b6b4be417a2caa250 In log_chopped.pcap, we use Wireshark’s search feature to look for the string CLIENT_RANDOM in the packet bytes. Select any packet from the search result and follow the TCP stream by right-clicking on it then clicking Follow -\u003e TCP Stream. This should open a new window showing the entire stream as ASCII:\nFrom here, it is trivial to extract the contents of sslkeylogfile. We can simply copy all lines containing the session keys starting from CLIENT_RANDOM and paste them into a file named sslkeylogfile.txt.\nThough, we’re not done quite yet. Since the attacker used xargs -n1 to display each argument into separate lines, the format of our keys is going to be incorrect. We need to replace the line characters \\n between ClientRandom and Secret into space characters, and this can be done using paste as so:\n$ paste -d\" \" - - - \u003c sslkeylogfile.txt \u003e sslkeylogfile\nThe sslkeylogfile should now contain 166 keys, as seen here:\n$ wc sslkeylogfile \u0026\u0026 md5sum sslkeylogfile\n166 498 29216 sslkeylogfile 9776acd3c0499be64e9653cb27f30720 sslkeylogfile With the session keys extracted, we can then decrypt the packets.\nInjecting secrets and decrypting TLS traffic There are two ways we can approach the decryption:\nUse Wireshark’s built-in support for master secret log files for TLS under Preferences -\u003e Protocol -\u003e TLS -\u003e (Pre)-Master-Secret log filename, select the sslkeylogfile we just extracted, and the packets will be automatically decrypted by Wireshark in the GUI. Use editcap to inject the secret to the .pcap file, as so: $ editcap --inject-secrets tls,sslkeylogfile log_chopped.pcap log_decrypted.pcap Either methods will allow us to read the contents of the packets, but the editcap approach will allow us to use command-line tools later to recover the files more easily. If you want to hand transcribe hexadecimals later on, then choose method 1. ;)\nRecovering flag.zip and pass.txt Looking at the HTTP/2 packets in log_decrypted.pcap with filter http2, we see there are GET requests to /files/flag.zip and /files/pass.txt:\nAlongside the HEADERS and Magic packets, we also see many DATA packets. Inspecting them further with Wireshark, we see that each of the DATA packet has a status of 206 Partial Content, they each carry either 1 or 2 bytes of data depending on if the Content-Type header is text/plain or application/zip, and nearly all of them have an unusual header Content-Range.\nIn essence, what’s happening here - is that the attacker is gradually sending either 1 or 2 bytes of data through HTTP/2. The bytes are ordered by the Content-Range header. For example, bytes 22-23/202 would mean the data in the packet belongs in byte locations 22 to 23, out of 202 bytes. This implies, in order for us to recover the two files, we need to piece together the individual bytes of data from all of the DATA packets according to the Content-Range header.\nIt is possible to recover the files by hand transcribing the hexadecimals from all 166 packets (if you’re up for the task). Fortunately, there is a tool that can help us with this. We can use tshark, which is a packet analysis tool much like Wireshark, but it is capable of quickly exporting the packets’ range and data as columns in the command-line, allowing us to easily recover the bytes.\n$ tshark -r log_decrypted.pcap -Y \"http2\" -T fields -e http2.headers.range -e http2.data.data | xargs -n2 \u003e bytes.txt\nHere, we first take log_decrypted.pcap as the input file (-r), using http2 as the display filter (-Y), and printing the fields (-T) of http2.headers.range and http2.data.data (-e). We also pipe the output to xargs -n2 to make each packet display neatly on one line instead of two, and finally output it to a bytes.txt file. The file should look something like this:\nbytes=53-53 31 bytes=34-34 32 bytes=27-27 39 bytes=52-52 36 bytes=55-55 66 ... We have the hexadecimal bytes of flag.zip and pass.txt, but the bytes are mixed together in one file and we want to separate them. To do this, we can pass it through a few more filters:\n$ cat bytes.txt | awk 'length($2)==2 {print $0}' | cut -d\"=\" -f2 | sort -n\nThis reads the contents of bytes.txt, and prints the line if the byte column has a length of 2. Then removes the “bytes=” string before the range, and sorts the values numerically. The result should be the hexadecimal bytes of pass.txt in order of the range, and will look something like this:\n0-0 30 1-1 65 2-2 64 3-3 62 4-4 63 ... We can verify that no bytes are missing from the output, and that all bytes are in the correct order.\nNow, we just have to remove the range column and we will get the password’s hex:\n$ cat bytes.txt | awk 'length($2)==2 {print $0}' | cut -d\"=\" -f2 | sort -n | cut -d\" \" -f2 \u003e pass.hex\nTo convert it from hexadecimal to bytes, we can use xxd:\n$ xxd -r -p pass.hex \u003e pass.txt\nNow repeat the process for flag.zip, but this time using length($2)==4 instead. We can also skip the intermediate hex file as so:\n$ cat bytes.txt | awk 'length($2)==4 {print $0}' | cut -d\"=\" -f2 | sort -n | cut -d\" \" -f2 | xxd -r -p \u003e flag.zip\nGetting the flag Now all that’s left to do is decompress flag.zip using pass.txt and get the flag!\n$ unzip flag.zip\nArchive: flag.zip [flag.zip] flag.txt password: 0edbca2531daefac9c5c84c016792713fd23681ea8bc1b3d088b617f75940313 extracting: flag.txt $ cat flag.txt\nIJCTF{aa51f2cc8eaf466a277da70db3a3c576} Resources friedrich/hans: IP over ICMP - https://github.com/friedrich/hans editcap - The Wireshark Network Analyzer 3.4.7 - https://www.wireshark.org/docs/man-pages/editcap.html NSS Key Log Format - Mozilla MDN - https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format Wireshark Tutorial: Decrypting HTTPS Traffic - https://unit42.paloaltonetworks.com/wireshark-tutorial-decrypting-https-traffic/ Decrypting TLS Streams With Wireshark: Part 1 - https://blog.didierstevens.com/2020/12/14/decrypting-tls-streams-with-wireshark-part-1/ tshark - The Wireshark Network Analyzer 3.4.7 - https://www.wireshark.org/docs/man-pages/tshark.html ","wordCount":"1852","inLanguage":"en","datePublished":"2021-07-26T05:38:55.413Z","dateModified":"2021-07-26T05:38:55.413Z","author":{"@type":"Person","name":"samiko"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.adelaideb9.com/posts/2021/ijctf/vault/"},"publisher":{"@type":"Organization","name":"AdelaideB9 Blog","logo":{"@type":"ImageObject","url":"https://blog.adelaideb9.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.adelaideb9.com/ accesskey=h title="AdelaideB9 Blog (Alt + H)">AdelaideB9 Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.adelaideb9.com/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://blog.adelaideb9.com/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://blog.adelaideb9.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.adelaideb9.com/>Home</a>&nbsp;»&nbsp;<a href=https://blog.adelaideb9.com/posts/>Posts</a></div><h1 class=post-title>Vault - IJCTF 2021</h1><div class=post-description>A forensics category challenge on recovering TLS session keys from a packet capture, and decrypting TLS traffic tunnelled over ICMP (ping) through a SOCKS proxy, then recovering files from partial HTTP/2 requests.</div><div class=post-meta><span title='2021-07-26 05:38:55.413 +0000 UTC'>July 26, 2021</span>&nbsp;·&nbsp;samiko</div></header><div class=post-content><h2 id=challenge-description>Challenge description<a hidden class=anchor aria-hidden=true href=#challenge-description>#</a></h2><p>A robber broke into our vault in the middle of night. There&rsquo;s an indication that the robber tried to steal some items which are considered as confidential assets. Could you figure it out?</p><p>Flag format: <code>IJCTF{[a-f0-9]{32}}</code></p><p>Author: <code>Avilia#1337</code></p><p>Hint #1: &ldquo;When the incident happened, the attacker got into our <code>IP over ICMP</code> tunnel network to access an <code>HTTP/2</code> web-server with <code>SSL</code> enabled.&rdquo;</p><p>Hint #2: &ldquo;Even so, our captured logs aren&rsquo;t precise enough. Each packet has an unusual timestamp and it&rsquo;s kinda messy&mldr;&rdquo;</p><p><a href=http://www.ijctf.tk/files/f98de00081d25c6c97d40ae157bb4338/log.tar.xz>log.tar.xz</a></p><h2 id=investigating-the-packet-capture>Investigating the packet capture<a hidden class=anchor aria-hidden=true href=#investigating-the-packet-capture>#</a></h2><p>We are provided with a <code>log.tar.xz</code> archive from the challenge description, which we can decompress using <code>xz</code> and <code>tar</code> as so:</p><p><code>$ xz -d log.tar.xz</code></p><p><code>$ tar -xvf log.tar</code></p><p>This should produce a <code>log.pcap</code> file.</p><p>Running <code>strings</code> against the <code>.pcap</code> file, we pipe the output to <code>sort</code> and <code>uniq</code> to only display unique entries, then <code>grep ......</code> to display only lines with length greater or equal to 6:</p><p><code>$ strings log.pcap | sort | uniq | grep ......</code></p><pre tabindex=0><code>...
CLIENT_RANDOM
Compressed: 202
Extracting archive: flag.zip
p7zip Version 16.02 (locale=C.UTF-8,Utf16=on,HugeFiles=on,32 bits,1 CPU LE)
&amp;p/home/pi/projects/ctf
python3 download.py flag.zip
python3 download.py pass.txt
uid=1000(pi) gid=1000(pi) groups=1000(pi),4(adm),20(dialout),24(cdrom),27(sudo),29(audio),44(video),46(plugdev),60(games),100(users),105(input),109(netdev),114(docker),116(lpadmin),997(gpio),998(i2c),999(spi)
whoami
xargs -n1 -a sslkeylogfile
</code></pre><p>We see mentions of files <code>flag.zip</code>, <code>pass.txt</code>, <code>download.py</code>, and <code>sslkeylogfile</code>, as well as commands such as <code>id</code>, <code>python3</code> and <code>xargs</code> being run.</p><p>Opening the packet capture file <code>log.pcap</code> in Wireshark, we see a conversation between <code>192.168.1.30</code> and <code>192.168.1.205</code> through ICMP (ping), along with some fragmented IPv4 packets.</p><ol><li>From the first hint, we know that the attacker used an IP over ICMP tunnel network to access an HTTP/2 web server with SSL.</li><li>From the second hint, we also know that the capture logs were imprecise and the packet timestamps were unusual.</li></ol><p>Looking at Wireshark, we notice some of the packets have negative time values. This should not be possible, packets cannot travel back in time before the capture started. Also, the frame numbers are all over the place and are not ordered correctly.</p><p>We can fix the packet ordering issue using the <code>reordercap</code> tool, which should come installed with Wireshark:</p><p><code>$ reordercap log.pcap log_ordered.pcap</code></p><p>If the reordering was successful, there should be 167 fragmented IPv4 packets with size of 1514 bytes in the newly created <code>log_ordered.pcap</code> file. With the ordering fixed, we can then start analysing the individual packets.</p><h2 id=splicing-the-packet-headers>Splicing the packet headers<a hidden class=anchor aria-hidden=true href=#splicing-the-packet-headers>#</a></h2><p>Looking at one of the fragmented IPv4 packets, we see that there is a data segment with 1480 bytes of data:</p><p><img loading=lazy src=https://i.imgur.com/tYUEddZ.png alt=https://i.imgur.com/tYUEddZ.png></p><p>At first, the data may look like random bytes. But, if we look carefully, we can see there is a malformed Ethernet header, followed by an IP header, and then a TCP header:</p><p><img loading=lazy src=https://i.imgur.com/5FixP4u.png alt=https://i.imgur.com/5FixP4u.png></p><p>Searching for the bytes in the malformed Ethernet header <code>00 00 4a e3 f9 24 34 44 68 61 6e 73 07</code>, we were able to determine the specific application used to establish the ICMP tunnel, called &ldquo;Hans&rdquo; (<a href=https://github.com/friedrich/hans/blob/master/src/worker.h>https://github.com/friedrich/hans</a>). This header is inserted by the Hans application. We can also see the <code>0x07</code> byte at the end, which is defined as <code>TYPE_DATA</code> in the source code under <code>src/worker.h</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Type</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    TYPE_RESET_CONNECTION <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    TYPE_CONNECTION_REQUEST <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>,
</span></span><span style=display:flex><span>    TYPE_CHALLENGE <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>    TYPE_CHALLENGE_RESPONSE <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>,
</span></span><span style=display:flex><span>    TYPE_CONNECTION_ACCEPT <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>,
</span></span><span style=display:flex><span>    TYPE_CHALLENGE_ERROR <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>,
</span></span><span style=display:flex><span>    TYPE_DATA <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>,
</span></span><span style=display:flex><span>    TYPE_POLL <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>,
</span></span><span style=display:flex><span>    TYPE_SERVER_FULL <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>We know the TCP data inside of the ICMP data has to contain the TLS traffic which the attacker used to exfiltrate data, or the handshakes associated with them. If we can somehow restore the original TLS packets, then there is a possibility where we can extract the session keys and use them to decrypt the rest of the packets.</p><p>This can be achieved by transplanting the Ethernet header from the ICMP packet to the ICMP data segment, and removing the magic/type header inserted by Hans. In fact, we can simplify it to only one cut operation by removing the TCP header and the Hans header altogether.</p><p>Using the <code>editcap</code> tool and following the documentation <a href=https://www.wireshark.org/docs/man-pages/editcap.html>here</a>, we cut away 33 bytes (20 bytes from TCP header of ICMP + 13 bytes from Hans) starting from offset byte 15 (after 14 bytes from Ethernet header of ICMP) for each packet, then export the packets into a <code>log_chopped.pcap</code> file:</p><p><code>$ editcap -C 15:33 log_ordered.pcap log_chopped.pcap</code></p><p>Opening <code>log_chopped.pcap</code> file in Wireshark, we see the ICMP packets have now changed into either TCP or Socks packets, the source/destination address and ports have also changed. This is likely because the attacker used a Socks proxy when attacking our victim. To combat this and allow Wireshark to read the traffic properly as TLS, we can add an entry to the &ldquo;Decode As&rdquo; list under the &ldquo;Analyze&rdquo; tab, pointing port 1080 to TLS:</p><p><img loading=lazy src=https://i.imgur.com/XYZz0Xq.png alt=https://i.imgur.com/XYZz0Xq.png></p><p>This basically tells Wireshark to treat all traffic on TCP port 1080 as TLS, and not as Socks.</p><h2 id=extracting-the-tls-session-keys>Extracting the TLS session keys<a hidden class=anchor aria-hidden=true href=#extracting-the-tls-session-keys>#</a></h2><p>Earlier, when we did <code>strings</code> on the <code>log.pcap</code> file, we noticed that the attacker ran <code>xargs -n1 -a sslkeylogfile</code> on the victim&rsquo;s system, which would effectively print the contents of <code>sslkeylogfile</code> to the output stream. We should be able to follow this output as it is not protected by TLS, and recover the TLS session keys.</p><p>From the <a href=https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format>Mozilla NSS key log documentations</a>, we know the <code>sslkeylogfile</code> follows a format of <code>&lt;Label> &lt;space> &lt;ClientRandom> &lt;space> &lt;Secret></code>. <code>ClientRandom</code> is encoded as 64 hexadecimal characters, and <code>Secret</code> is encoded as 96 hexadecimal characters (for TLS 1.0-2). For example, a key may look like this:</p><pre tabindex=0><code>CLIENT_RANDOM cf6b8752f4b47c9c28b07ba7da366f98afcc335931f08df83c30ebe2c7bcce32 a832cf19fa6b414fce74fa796b39d898c0825991547eebd20abe951ad2c586490d2703e4f596de3b6b4be417a2caa250
</code></pre><p>In <code>log_chopped.pcap</code>, we use Wireshark&rsquo;s search feature to look for the string <code>CLIENT_RANDOM</code> in the packet bytes. Select any packet from the search result and follow the TCP stream by right-clicking on it then clicking <code>Follow -> TCP Stream</code>. This should open a new window showing the entire stream as ASCII:</p><p><img loading=lazy src=https://i.imgur.com/txTocC4.png alt=https://i.imgur.com/txTocC4.png></p><p>From here, it is trivial to extract the contents of <code>sslkeylogfile</code>. We can simply copy all lines containing the session keys starting from <code>CLIENT_RANDOM</code> and paste them into a file named <code>sslkeylogfile.txt</code>.</p><p>Though, we&rsquo;re not done quite yet. Since the attacker used <code>xargs -n1</code> to display each argument into separate lines, the format of our keys is going to be incorrect. We need to replace the line characters <code>\n</code> between <code>ClientRandom</code> and <code>Secret</code> into space characters, and this can be done using <code>paste</code> as so:</p><p><code>$ paste -d" " - - - &lt; sslkeylogfile.txt > sslkeylogfile</code></p><p>The <code>sslkeylogfile</code> should now contain 166 keys, as seen here:</p><p><code>$ wc sslkeylogfile && md5sum sslkeylogfile</code></p><pre tabindex=0><code>166   498 29216 sslkeylogfile
9776acd3c0499be64e9653cb27f30720  sslkeylogfile
</code></pre><p>With the session keys extracted, we can then decrypt the packets.</p><h2 id=injecting-secrets-and-decrypting-tls-traffic>Injecting secrets and decrypting TLS traffic<a hidden class=anchor aria-hidden=true href=#injecting-secrets-and-decrypting-tls-traffic>#</a></h2><p>There are two ways we can approach the decryption:</p><ol><li>Use Wireshark&rsquo;s built-in support for master secret log files for TLS under <code>Preferences -> Protocol -> TLS -> (Pre)-Master-Secret log filename</code>, select the <code>sslkeylogfile</code> we just extracted, and the packets will be automatically decrypted by Wireshark in the GUI.</li><li>Use <code>editcap</code> to inject the secret to the <code>.pcap</code> file, as so:<br><code>$ editcap --inject-secrets tls,sslkeylogfile log_chopped.pcap log_decrypted.pcap</code></li></ol><p>Either methods will allow us to read the contents of the packets, but the <code>editcap</code> approach will allow us to use command-line tools later to recover the files more easily. If you want to hand transcribe hexadecimals later on, then choose method 1. ;)</p><h2 id=recovering-flagzip-and-passtxt>Recovering flag.zip and pass.txt<a hidden class=anchor aria-hidden=true href=#recovering-flagzip-and-passtxt>#</a></h2><p>Looking at the HTTP/2 packets in <code>log_decrypted.pcap</code> with filter <code>http2</code>, we see there are GET requests to <code>/files/flag.zip</code> and <code>/files/pass.txt</code>:</p><p><img loading=lazy src=https://i.imgur.com/N9bZFyg.png alt=https://i.imgur.com/N9bZFyg.png></p><p>Alongside the <code>HEADERS</code> and <code>Magic</code> packets, we also see many <code>DATA</code> packets. Inspecting them further with Wireshark, we see that each of the <code>DATA</code> packet has a status of <code>206 Partial Content</code>, they each carry either 1 or 2 bytes of data depending on if the <code>Content-Type</code> header is <code>text/plain</code> or <code>application/zip</code>, and nearly all of them have an unusual header <code>Content-Range</code>.</p><p><img loading=lazy src=https://i.imgur.com/YmYfG18.png alt=https://i.imgur.com/YmYfG18.png></p><p>In essence, what&rsquo;s happening here - is that the attacker is gradually sending either 1 or 2 bytes of data through HTTP/2. The bytes are ordered by the <code>Content-Range</code> header. For example, <code>bytes 22-23/202</code> would mean the data in the packet belongs in byte locations 22 to 23, out of 202 bytes. This implies, in order for us to recover the two files, we need to piece together the individual bytes of data from all of the <code>DATA</code> packets according to the <code>Content-Range</code> header.</p><p>It is possible to recover the files by hand transcribing the hexadecimals from all 166 packets (if you&rsquo;re up for the task). Fortunately, there is a tool that can help us with this. We can use <code>tshark</code>, which is a packet analysis tool much like Wireshark, but it is capable of quickly exporting the packets&rsquo; range and data as columns in the command-line, allowing us to easily recover the bytes.</p><p><code>$ tshark -r log_decrypted.pcap -Y "http2" -T fields -e http2.headers.range -e http2.data.data | xargs -n2 > bytes.txt</code></p><p>Here, we first take <code>log_decrypted.pcap</code> as the input file (<code>-r</code>), using <code>http2</code> as the display filter (<code>-Y</code>), and printing the fields (<code>-T</code>) of <code>http2.headers.range</code> and <code>http2.data.data</code> (<code>-e</code>). We also pipe the output to <code>xargs -n2</code> to make each packet display neatly on one line instead of two, and finally output it to a <code>bytes.txt</code> file. The file should look something like this:</p><pre tabindex=0><code>bytes=53-53 31
bytes=34-34 32
bytes=27-27 39
bytes=52-52 36
bytes=55-55 66
...
</code></pre><p>We have the hexadecimal bytes of <code>flag.zip</code> and <code>pass.txt</code>, but the bytes are mixed together in one file and we want to separate them. To do this, we can pass it through a few more filters:</p><p><code>$ cat bytes.txt | awk 'length($2)==2 {print $0}' | cut -d"=" -f2 | sort -n</code></p><p>This reads the contents of <code>bytes.txt</code>, and prints the line if the byte column has a length of 2. Then removes the &ldquo;bytes=&rdquo; string before the range, and sorts the values numerically. The result should be the hexadecimal bytes of <code>pass.txt</code> in order of the range, and will look something like this:</p><pre tabindex=0><code>0-0 30
1-1 65
2-2 64
3-3 62
4-4 63
...
</code></pre><p>We can verify that no bytes are missing from the output, and that all bytes are in the correct order.</p><p>Now, we just have to remove the range column and we will get the password&rsquo;s hex:</p><p><code>$ cat bytes.txt | awk 'length($2)==2 {print $0}' | cut -d"=" -f2 | sort -n | cut -d" " -f2 > pass.hex</code></p><p>To convert it from hexadecimal to bytes, we can use <code>xxd</code>:</p><p><code>$ xxd -r -p pass.hex > pass.txt</code></p><p>Now repeat the process for <code>flag.zip</code>, but this time using <code>length($2)==4</code> instead. We can also skip the intermediate hex file as so:</p><p><code>$ cat bytes.txt | awk 'length($2)==4 {print $0}' | cut -d"=" -f2 | sort -n | cut -d" " -f2 | xxd -r -p > flag.zip</code></p><h2 id=getting-the-flag>Getting the flag<a hidden class=anchor aria-hidden=true href=#getting-the-flag>#</a></h2><p>Now all that&rsquo;s left to do is decompress <code>flag.zip</code> using <code>pass.txt</code> and get the flag!</p><p><code>$ unzip flag.zip</code></p><pre tabindex=0><code>Archive:  flag.zip
[flag.zip] flag.txt password: 0edbca2531daefac9c5c84c016792713fd23681ea8bc1b3d088b617f75940313
 extracting: flag.txt
</code></pre><p><code>$ cat flag.txt</code></p><pre tabindex=0><code>IJCTF{aa51f2cc8eaf466a277da70db3a3c576}
</code></pre><h2 id=resources>Resources<a hidden class=anchor aria-hidden=true href=#resources>#</a></h2><ol><li>friedrich/hans: IP over ICMP - <a href=https://github.com/friedrich/hans>https://github.com/friedrich/hans</a></li><li>editcap - The Wireshark Network Analyzer 3.4.7 - <a href=https://www.wireshark.org/docs/man-pages/editcap.html>https://www.wireshark.org/docs/man-pages/editcap.html</a></li><li>NSS Key Log Format - Mozilla MDN - <a href=https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format>https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format</a></li><li>Wireshark Tutorial: Decrypting HTTPS Traffic - <a href=https://unit42.paloaltonetworks.com/wireshark-tutorial-decrypting-https-traffic/>https://unit42.paloaltonetworks.com/wireshark-tutorial-decrypting-https-traffic/</a></li><li>Decrypting TLS Streams With Wireshark: Part 1 - <a href=https://blog.didierstevens.com/2020/12/14/decrypting-tls-streams-with-wireshark-part-1/>https://blog.didierstevens.com/2020/12/14/decrypting-tls-streams-with-wireshark-part-1/</a></li><li>tshark - The Wireshark Network Analyzer 3.4.7 - <a href=https://www.wireshark.org/docs/man-pages/tshark.html>https://www.wireshark.org/docs/man-pages/tshark.html</a></li></ol></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.adelaideb9.com/>AdelaideB9 Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>